{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { complex } from '../ops/complex';\nimport { imag } from '../ops/imag';\nimport { op } from '../ops/operation';\nimport { real } from '../ops/real';\nimport { assert } from '../util';\nimport { scalar, zeros } from './tensor_ops';\n/**\n * Fast Fourier transform.\n *\n * Computes the 1-dimensional discrete Fourier transform over the inner-most\n * dimension of input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n * const imag = tf.tensor1d([1, 2, 3]);\n * const x = tf.complex(real, imag);\n *\n * x.fft().print();  // tf.spectral.fft(x).print();\n * ```\n * @param input The complex input to compute an fft over.\n */\n\n/**\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\n\nfunction fft_(input) {\n  assert(input.dtype === 'complex64', () => `The dtype for tf.spectral.fft() must be complex64 ` + `but got ${input.dtype}.`); // Collapse all outer dimensions to a single batch dimension.\n\n  const innerDimensionSize = input.shape[input.shape.length - 1];\n  const batch = input.size / innerDimensionSize;\n  const input2D = input.as2D(batch, innerDimensionSize);\n  const ret = ENGINE.runKernelFunc(backend => backend.fft(input2D), {\n    input\n  });\n  return ret.reshape(input.shape);\n}\n/**\n * Inverse fast Fourier transform.\n *\n * Computes the inverse 1-dimensional discrete Fourier transform over the\n * inner-most dimension of input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n * const imag = tf.tensor1d([1, 2, 3]);\n * const x = tf.complex(real, imag);\n *\n * x.ifft().print();  // tf.spectral.ifft(x).print();\n * ```\n * @param input The complex input to compute an ifft over.\n */\n\n/**\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\n\n\nfunction ifft_(input) {\n  assert(input.dtype === 'complex64', () => `The dtype for tf.spectral.ifft() must be complex64 ` + `but got ${input.dtype}.`); // Collapse all outer dimensions to a single batch dimension.\n\n  const innerDimensionSize = input.shape[input.shape.length - 1];\n  const batch = input.size / innerDimensionSize;\n  const input2D = input.as2D(batch, innerDimensionSize);\n  const ret = ENGINE.runKernelFunc(backend => backend.ifft(input2D), {\n    input\n  });\n  return ret.reshape(input.shape);\n}\n/**\n * Real value input fast Fourier transform.\n *\n * Computes the 1-dimensional discrete Fourier transform over the\n * inner-most dimension of the real input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n *\n * real.rfft().print();\n * ```\n * @param input The real value input to compute an rfft over.\n */\n\n/**\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\n\n\nfunction rfft_(input, fftLength) {\n  assert(input.dtype === 'float32', () => `The dtype for rfft() must be real value but got ${input.dtype}`);\n  let innerDimensionSize = input.shape[input.shape.length - 1];\n  const batch = input.size / innerDimensionSize;\n  let adjustedInput;\n\n  if (fftLength != null && fftLength < innerDimensionSize) {\n    // Need to crop\n    const begin = input.shape.map(v => 0);\n    const size = input.shape.map(v => v);\n    size[input.shape.length - 1] = fftLength;\n    adjustedInput = input.slice(begin, size);\n    innerDimensionSize = fftLength;\n  } else if (fftLength != null && fftLength > innerDimensionSize) {\n    // Need to pad with zeros\n    const zerosShape = input.shape.map(v => v);\n    zerosShape[input.shape.length - 1] = fftLength - innerDimensionSize;\n    adjustedInput = input.concat(zeros(zerosShape), input.shape.length - 1);\n    innerDimensionSize = fftLength;\n  } else {\n    adjustedInput = input;\n  } // Complement the input with zero imaginary numbers.\n\n\n  const zerosInput = adjustedInput.zerosLike();\n  const complexInput = complex(adjustedInput, zerosInput).as2D(batch, innerDimensionSize);\n  const ret = fft(complexInput); // Exclude complex conjugations. These conjugations are put symmetrically.\n\n  const half = Math.floor(innerDimensionSize / 2) + 1;\n  const realValues = real(ret);\n  const imagValues = imag(ret);\n  const realComplexConjugate = realValues.split([half, innerDimensionSize - half], realValues.shape.length - 1);\n  const imagComplexConjugate = imagValues.split([half, innerDimensionSize - half], imagValues.shape.length - 1);\n  const outputShape = adjustedInput.shape.slice();\n  outputShape[adjustedInput.shape.length - 1] = half;\n  return complex(realComplexConjugate[0], imagComplexConjugate[0]).reshape(outputShape);\n}\n/**\n * Inversed real value input fast Fourier transform.\n *\n * Computes the 1-dimensional inversed discrete Fourier transform over the\n * inner-most dimension of the real input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n * const imag = tf.tensor1d([0, 0, 0]);\n * const x = tf.complex(real, imag);\n *\n * x.irfft().print();\n * ```\n * @param input The real value input to compute an irfft over.\n */\n\n/**\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\n\n\nfunction irfft_(input) {\n  const innerDimensionSize = input.shape[input.shape.length - 1];\n  const batch = input.size / innerDimensionSize;\n\n  if (innerDimensionSize <= 2) {\n    const complexInput = input.as2D(batch, innerDimensionSize);\n    const ret = ifft(complexInput);\n    return real(ret);\n  } else {\n    // The length of unique components of the DFT of a real-valued signal\n    // is 2 * (input_len - 1)\n    const outputShape = [batch, 2 * (innerDimensionSize - 1)];\n    const realInput = real(input).as2D(batch, innerDimensionSize);\n    const imagInput = imag(input).as2D(batch, innerDimensionSize);\n    const realConjugate = realInput.slice([0, 1], [batch, innerDimensionSize - 2]).reverse(1);\n    const imagConjugate = imagInput.slice([0, 1], [batch, innerDimensionSize - 2]).reverse(1).mul(scalar(-1));\n    const r = realInput.concat(realConjugate, 1);\n    const i = imagInput.concat(imagConjugate, 1);\n    const complexInput = complex(r, i).as2D(outputShape[0], outputShape[1]);\n    const ret = ifft(complexInput);\n    return real(ret);\n  }\n}\n\nexport const fft = op({\n  fft_\n});\nexport const ifft = op({\n  ifft_\n});\nexport const rfft = op({\n  rfft_\n});\nexport const irfft = op({\n  irfft_\n});","map":{"version":3,"sources":["../../src/ops/spectral_ops.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { complex } from '../ops/complex';\nimport { imag } from '../ops/imag';\nimport { op } from '../ops/operation';\nimport { real } from '../ops/real';\nimport { assert } from '../util';\nimport { scalar, zeros } from './tensor_ops';\n/**\n * Fast Fourier transform.\n *\n * Computes the 1-dimensional discrete Fourier transform over the inner-most\n * dimension of input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n * const imag = tf.tensor1d([1, 2, 3]);\n * const x = tf.complex(real, imag);\n *\n * x.fft().print();  // tf.spectral.fft(x).print();\n * ```\n * @param input The complex input to compute an fft over.\n */\n/**\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\nfunction fft_(input) {\n    assert(input.dtype === 'complex64', () => `The dtype for tf.spectral.fft() must be complex64 ` +\n        `but got ${input.dtype}.`);\n    // Collapse all outer dimensions to a single batch dimension.\n    const innerDimensionSize = input.shape[input.shape.length - 1];\n    const batch = input.size / innerDimensionSize;\n    const input2D = input.as2D(batch, innerDimensionSize);\n    const ret = ENGINE.runKernelFunc(backend => backend.fft(input2D), { input });\n    return ret.reshape(input.shape);\n}\n/**\n * Inverse fast Fourier transform.\n *\n * Computes the inverse 1-dimensional discrete Fourier transform over the\n * inner-most dimension of input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n * const imag = tf.tensor1d([1, 2, 3]);\n * const x = tf.complex(real, imag);\n *\n * x.ifft().print();  // tf.spectral.ifft(x).print();\n * ```\n * @param input The complex input to compute an ifft over.\n */\n/**\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\nfunction ifft_(input) {\n    assert(input.dtype === 'complex64', () => `The dtype for tf.spectral.ifft() must be complex64 ` +\n        `but got ${input.dtype}.`);\n    // Collapse all outer dimensions to a single batch dimension.\n    const innerDimensionSize = input.shape[input.shape.length - 1];\n    const batch = input.size / innerDimensionSize;\n    const input2D = input.as2D(batch, innerDimensionSize);\n    const ret = ENGINE.runKernelFunc(backend => backend.ifft(input2D), { input });\n    return ret.reshape(input.shape);\n}\n/**\n * Real value input fast Fourier transform.\n *\n * Computes the 1-dimensional discrete Fourier transform over the\n * inner-most dimension of the real input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n *\n * real.rfft().print();\n * ```\n * @param input The real value input to compute an rfft over.\n */\n/**\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\nfunction rfft_(input, fftLength) {\n    assert(input.dtype === 'float32', () => `The dtype for rfft() must be real value but got ${input.dtype}`);\n    let innerDimensionSize = input.shape[input.shape.length - 1];\n    const batch = input.size / innerDimensionSize;\n    let adjustedInput;\n    if (fftLength != null && fftLength < innerDimensionSize) {\n        // Need to crop\n        const begin = input.shape.map(v => 0);\n        const size = input.shape.map(v => v);\n        size[input.shape.length - 1] = fftLength;\n        adjustedInput = input.slice(begin, size);\n        innerDimensionSize = fftLength;\n    }\n    else if (fftLength != null && fftLength > innerDimensionSize) {\n        // Need to pad with zeros\n        const zerosShape = input.shape.map(v => v);\n        zerosShape[input.shape.length - 1] = fftLength - innerDimensionSize;\n        adjustedInput = input.concat(zeros(zerosShape), input.shape.length - 1);\n        innerDimensionSize = fftLength;\n    }\n    else {\n        adjustedInput = input;\n    }\n    // Complement the input with zero imaginary numbers.\n    const zerosInput = adjustedInput.zerosLike();\n    const complexInput = complex(adjustedInput, zerosInput).as2D(batch, innerDimensionSize);\n    const ret = fft(complexInput);\n    // Exclude complex conjugations. These conjugations are put symmetrically.\n    const half = Math.floor(innerDimensionSize / 2) + 1;\n    const realValues = real(ret);\n    const imagValues = imag(ret);\n    const realComplexConjugate = realValues.split([half, innerDimensionSize - half], realValues.shape.length - 1);\n    const imagComplexConjugate = imagValues.split([half, innerDimensionSize - half], imagValues.shape.length - 1);\n    const outputShape = adjustedInput.shape.slice();\n    outputShape[adjustedInput.shape.length - 1] = half;\n    return complex(realComplexConjugate[0], imagComplexConjugate[0])\n        .reshape(outputShape);\n}\n/**\n * Inversed real value input fast Fourier transform.\n *\n * Computes the 1-dimensional inversed discrete Fourier transform over the\n * inner-most dimension of the real input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n * const imag = tf.tensor1d([0, 0, 0]);\n * const x = tf.complex(real, imag);\n *\n * x.irfft().print();\n * ```\n * @param input The real value input to compute an irfft over.\n */\n/**\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\nfunction irfft_(input) {\n    const innerDimensionSize = input.shape[input.shape.length - 1];\n    const batch = input.size / innerDimensionSize;\n    if (innerDimensionSize <= 2) {\n        const complexInput = input.as2D(batch, innerDimensionSize);\n        const ret = ifft(complexInput);\n        return real(ret);\n    }\n    else {\n        // The length of unique components of the DFT of a real-valued signal\n        // is 2 * (input_len - 1)\n        const outputShape = [batch, 2 * (innerDimensionSize - 1)];\n        const realInput = real(input).as2D(batch, innerDimensionSize);\n        const imagInput = imag(input).as2D(batch, innerDimensionSize);\n        const realConjugate = realInput.slice([0, 1], [batch, innerDimensionSize - 2]).reverse(1);\n        const imagConjugate = imagInput.slice([0, 1], [batch, innerDimensionSize - 2])\n            .reverse(1)\n            .mul(scalar(-1));\n        const r = realInput.concat(realConjugate, 1);\n        const i = imagInput.concat(imagConjugate, 1);\n        const complexInput = complex(r, i).as2D(outputShape[0], outputShape[1]);\n        const ret = ifft(complexInput);\n        return real(ret);\n    }\n}\nexport const fft = op({ fft_ });\nexport const ifft = op({ ifft_ });\nexport const rfft = op({ rfft_ });\nexport const irfft = op({ irfft_ });\n//# sourceMappingURL=spectral_ops.js.map"]},"metadata":{},"sourceType":"module"}