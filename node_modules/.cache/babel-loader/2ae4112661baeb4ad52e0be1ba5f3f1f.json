{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\nimport { slice } from './slice';\nimport { computeOutShape, maskToAxes, startForAxis, startIndicesWithElidedDims, stopForAxis, stopIndicesWithElidedDims, stridesForAxis, stridesWithElidedDims } from './slice_util';\n/**\n * Extracts a strided slice of a tensor.\n *\n * Roughly speaking, this op extracts a slice of size (end-begin)/stride from\n * the given input tensor (x). Starting at the location specified by begin the\n * slice continues by adding stride to the index until all dimensions are not\n * less than end. Note that a stride can be negative, which causes a reverse\n * slice.\n *\n * ```js\n * const t = tf.tensor3d([1, 1, 1 ,2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6],\n *    [3, 2, 3]);\n * t.stridedSlice([1, 0, 0], [2, 1, 3], [1, 1, 1]).print()  // [[[3, 3, 3]]]\n * t.stridedSlice([1, 0, 0], [2, 2, 3], [1, 1, 1]).print()  // [[[3, 3, 3],\n *                                                     // [4, 4, 4]]]\n * t.stridedSlice([1, -1, 0], [2, -3, 3], [1, -1, 1]).print() // [[[4, 4, 4],\n *                                                     // [3, 3, 3]]]\n * ```\n *\n * @param x The tensor to stride slice.\n * @param begin The coordinates to start the slice from.\n * @param end: The coordinates to end the slice at.\n * @param strides: The size of the slice.\n * @param beginMask: If the ith bit of beginMask is set, begin[i] is ignored\n *      and the fullest possible range in that dimension is used instead.\n * @param endMask: If the ith bit of endMask is set, end[i] is ignored\n *      and the fullest possible range in that dimension is used instead.\n * @param shrinkAxisMask: a bitmask where bit i implies that\n * the ith specification should shrink the dimensionality. begin and end must\n * imply a slice of size 1 in the dimension.\n */\n\n/** @doc {heading: 'Operations', subheading: 'Slicing and Joining'} */\n\nfunction stridedSlice_(x, begin, end, strides, beginMask = 0, endMask = 0, ellipsisMask = 0, newAxisMask = 0, shrinkAxisMask = 0) {\n  if (strides == null) {\n    strides = new Array(begin.length);\n  }\n\n  const ellipsisAxes = maskToAxes(ellipsisMask);\n\n  if (ellipsisAxes.length > 1) {\n    throw new Error('Multiple ellipses in slice is not allowed.');\n  }\n\n  if (ellipsisMask !== 0 && newAxisMask !== 0) {\n    throw new Error('Using both ellipsisMask and newAxisMask is not yet supported.');\n  }\n\n  if (ellipsisMask !== 0 && shrinkAxisMask !== 0) {\n    throw new Error('Using both ellipsisMask and shrinkAxisMask is not yet supported.');\n  }\n\n  let $x = convertToTensor(x, 'x', 'stridedSlice');\n  const numInterpolatedAxes = $x.rank - begin.length; // Expand the dims of x based on the newAxisMask.\n\n  const expandAxes = maskToAxes(newAxisMask);\n  const newShape = $x.shape.slice();\n  expandAxes.forEach(axis => {\n    begin[axis] = 0;\n    end[axis] = 1;\n    newShape.splice(axis, 0, 1);\n  });\n  $x = $x.reshape(newShape); // Normalize the start, end and strides.\n\n  for (let axis = 0; axis < $x.rank; axis++) {\n    begin[axis] = startForAxis(beginMask, begin, strides, $x.shape, axis, ellipsisMask);\n    end[axis] = stopForAxis(endMask, end, strides, $x.shape, axis, ellipsisMask);\n    strides[axis] = stridesForAxis(strides, axis, ellipsisMask);\n  }\n\n  if (ellipsisAxes.length && numInterpolatedAxes > 0) {\n    const fullIndex = ellipsisAxes[0]; // The ellipsis applies to the masked index as well as any dimensions that\n    // were interpolated as full selection.\n\n    const numElidedAxes = numInterpolatedAxes + 1;\n    begin = startIndicesWithElidedDims(begin, fullIndex, numElidedAxes);\n    end = stopIndicesWithElidedDims(end, fullIndex, numElidedAxes, $x.shape);\n    strides = stridesWithElidedDims(strides, fullIndex, numElidedAxes);\n  }\n\n  const shrinkAxes = maskToAxes(shrinkAxisMask); // Adjust the ends based on the shrink mask.\n\n  shrinkAxes.forEach(axis => {\n    end[axis] = begin[axis] + 1;\n    strides[axis] = 1;\n  }); // Figure out the output shape.\n\n  const size = computeOutShape(begin, end, strides); // Remove the axes based on shrinkMask.\n\n  const outShape = size.filter((_, axis) => shrinkAxes.indexOf(axis) === -1);\n  const nonStrided = strides.every(v => v === 1);\n\n  if (nonStrided) {\n    return slice($x, begin, size).reshape(outShape);\n  }\n\n  const res = ENGINE.runKernelFunc(backend => backend.stridedSlice($x, begin, end, strides), {\n    $x\n  });\n  return res.reshape(outShape);\n}\n\nexport const stridedSlice = op({\n  stridedSlice_\n});","map":{"version":3,"sources":["../../src/ops/strided_slice.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\nimport { slice } from './slice';\nimport { computeOutShape, maskToAxes, startForAxis, startIndicesWithElidedDims, stopForAxis, stopIndicesWithElidedDims, stridesForAxis, stridesWithElidedDims } from './slice_util';\n/**\n * Extracts a strided slice of a tensor.\n *\n * Roughly speaking, this op extracts a slice of size (end-begin)/stride from\n * the given input tensor (x). Starting at the location specified by begin the\n * slice continues by adding stride to the index until all dimensions are not\n * less than end. Note that a stride can be negative, which causes a reverse\n * slice.\n *\n * ```js\n * const t = tf.tensor3d([1, 1, 1 ,2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6],\n *    [3, 2, 3]);\n * t.stridedSlice([1, 0, 0], [2, 1, 3], [1, 1, 1]).print()  // [[[3, 3, 3]]]\n * t.stridedSlice([1, 0, 0], [2, 2, 3], [1, 1, 1]).print()  // [[[3, 3, 3],\n *                                                     // [4, 4, 4]]]\n * t.stridedSlice([1, -1, 0], [2, -3, 3], [1, -1, 1]).print() // [[[4, 4, 4],\n *                                                     // [3, 3, 3]]]\n * ```\n *\n * @param x The tensor to stride slice.\n * @param begin The coordinates to start the slice from.\n * @param end: The coordinates to end the slice at.\n * @param strides: The size of the slice.\n * @param beginMask: If the ith bit of beginMask is set, begin[i] is ignored\n *      and the fullest possible range in that dimension is used instead.\n * @param endMask: If the ith bit of endMask is set, end[i] is ignored\n *      and the fullest possible range in that dimension is used instead.\n * @param shrinkAxisMask: a bitmask where bit i implies that\n * the ith specification should shrink the dimensionality. begin and end must\n * imply a slice of size 1 in the dimension.\n */\n/** @doc {heading: 'Operations', subheading: 'Slicing and Joining'} */\nfunction stridedSlice_(x, begin, end, strides, beginMask = 0, endMask = 0, ellipsisMask = 0, newAxisMask = 0, shrinkAxisMask = 0) {\n    if (strides == null) {\n        strides = new Array(begin.length);\n    }\n    const ellipsisAxes = maskToAxes(ellipsisMask);\n    if (ellipsisAxes.length > 1) {\n        throw new Error('Multiple ellipses in slice is not allowed.');\n    }\n    if (ellipsisMask !== 0 && newAxisMask !== 0) {\n        throw new Error('Using both ellipsisMask and newAxisMask is not yet supported.');\n    }\n    if (ellipsisMask !== 0 && shrinkAxisMask !== 0) {\n        throw new Error('Using both ellipsisMask and shrinkAxisMask is not yet supported.');\n    }\n    let $x = convertToTensor(x, 'x', 'stridedSlice');\n    const numInterpolatedAxes = $x.rank - begin.length;\n    // Expand the dims of x based on the newAxisMask.\n    const expandAxes = maskToAxes(newAxisMask);\n    const newShape = $x.shape.slice();\n    expandAxes.forEach(axis => {\n        begin[axis] = 0;\n        end[axis] = 1;\n        newShape.splice(axis, 0, 1);\n    });\n    $x = $x.reshape(newShape);\n    // Normalize the start, end and strides.\n    for (let axis = 0; axis < $x.rank; axis++) {\n        begin[axis] =\n            startForAxis(beginMask, begin, strides, $x.shape, axis, ellipsisMask);\n        end[axis] =\n            stopForAxis(endMask, end, strides, $x.shape, axis, ellipsisMask);\n        strides[axis] = stridesForAxis(strides, axis, ellipsisMask);\n    }\n    if (ellipsisAxes.length && numInterpolatedAxes > 0) {\n        const fullIndex = ellipsisAxes[0];\n        // The ellipsis applies to the masked index as well as any dimensions that\n        // were interpolated as full selection.\n        const numElidedAxes = numInterpolatedAxes + 1;\n        begin = startIndicesWithElidedDims(begin, fullIndex, numElidedAxes);\n        end = stopIndicesWithElidedDims(end, fullIndex, numElidedAxes, $x.shape);\n        strides = stridesWithElidedDims(strides, fullIndex, numElidedAxes);\n    }\n    const shrinkAxes = maskToAxes(shrinkAxisMask);\n    // Adjust the ends based on the shrink mask.\n    shrinkAxes.forEach(axis => {\n        end[axis] = begin[axis] + 1;\n        strides[axis] = 1;\n    });\n    // Figure out the output shape.\n    const size = computeOutShape(begin, end, strides);\n    // Remove the axes based on shrinkMask.\n    const outShape = size.filter((_, axis) => shrinkAxes.indexOf(axis) === -1);\n    const nonStrided = strides.every(v => v === 1);\n    if (nonStrided) {\n        return slice($x, begin, size).reshape(outShape);\n    }\n    const res = ENGINE.runKernelFunc(backend => backend.stridedSlice($x, begin, end, strides), { $x });\n    return res.reshape(outShape);\n}\nexport const stridedSlice = op({ stridedSlice_ });\n//# sourceMappingURL=strided_slice.js.map"]},"metadata":{},"sourceType":"module"}