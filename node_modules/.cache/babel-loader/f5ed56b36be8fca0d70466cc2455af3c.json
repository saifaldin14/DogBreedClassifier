{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { assertTypesMatch } from '../tensor_util';\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { op } from './operation';\nimport { pow } from './pow';\nimport { scalar } from './tensor_ops';\n/**\n * Compute the moving average of a variable.\n *\n * Without zeroDebias, the moving average operation is defined by:\n *   `v += delta`\n * where\n *   `delta = (1 - decay) * (x - v)`\n *\n * With zeroDebias (default), the `delta` term is scaled to debias the\n * effect of the (assumed) zero-initialization of `v`.\n *   `delta /= (1 - decay ^ step)`\n *\n * For more details on the zero-debiasing algorithm, see:\n *   https://arxiv.org/abs/1412.6980\n *\n * Note that this function is completely stateless and does not keep track of\n * step count. The step count needs to be maintained by the caller and passed\n * in as `step`.\n *\n * @param v The current moving average value.\n * @param x New input value, must have the same shape and dtype as `v`.\n * @param decay The decay factor. Typical values are 0.95 and 0.99.\n * @param step Step count.\n * @param zeroDebias: Whether zeroDebias is to be performed (default: `true`).\n * @returns The new moving average value.\n */\n\n/** @doc {heading: 'Operations', subheading: 'Moving Average'} */\n\nfunction movingAverage_(v, x, decay, step, zeroDebias = true) {\n  const $v = convertToTensor(v, 'v', 'movingAverage');\n  const $x = convertToTensor(x, 'x', 'movingAverage');\n  const $decay = convertToTensor(decay, 'decay', 'movingAverage');\n  assertTypesMatch($v, $x);\n  util.assert(util.arraysEqual($v.shape, $x.shape), () => 'Shape mismatch in v and x');\n  const one = scalar(1);\n  const oneMinusDecay = one.sub($decay);\n  let update = $x.sub($v).mul(oneMinusDecay);\n\n  if (zeroDebias) {\n    util.assert(step != null, () => 'When using zeroDebias: true, step is required.');\n    const $step = convertToTensor(step, 'step', 'movingAverage');\n    update = update.div(one.sub(pow($decay, $step)));\n  }\n\n  return $v.add(update);\n}\n\nexport const movingAverage = op({\n  movingAverage_\n});","map":{"version":3,"sources":["../../src/ops/moving_average.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAkBA,SAAQ,gBAAR,QAA+B,gBAA/B;AACA,SAAQ,eAAR,QAA8B,oBAA9B;AAEA,OAAO,KAAK,IAAZ,MAAsB,SAAtB;AAEA,SAAQ,EAAR,QAAiB,aAAjB;AACA,SAAQ,GAAR,QAAkB,OAAlB;AACA,SAAQ,MAAR,QAAqB,cAArB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;;AACA,SAAS,cAAT,CACI,CADJ,EACqB,CADrB,EACsC,KADtC,EAEI,IAFJ,EAE0B,UAAU,GAAG,IAFvC,EAE2C;AACzC,QAAM,EAAE,GAAG,eAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,eAAT,CAA1B;AACA,QAAM,EAAE,GAAG,eAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,eAAT,CAA1B;AACA,QAAM,MAAM,GAAG,eAAe,CAAC,KAAD,EAAQ,OAAR,EAAiB,eAAjB,CAA9B;AAEA,EAAA,gBAAgB,CAAC,EAAD,EAAK,EAAL,CAAhB;AACA,EAAA,IAAI,CAAC,MAAL,CACI,IAAI,CAAC,WAAL,CAAiB,EAAE,CAAC,KAApB,EAA2B,EAAE,CAAC,KAA9B,CADJ,EAC0C,MAAM,2BADhD;AAGA,QAAM,GAAG,GAAG,MAAM,CAAC,CAAD,CAAlB;AACA,QAAM,aAAa,GAAG,GAAG,CAAC,GAAJ,CAAQ,MAAR,CAAtB;AAEA,MAAI,MAAM,GAAG,EAAE,CAAC,GAAH,CAAO,EAAP,EAAW,GAAX,CAAe,aAAf,CAAb;;AACA,MAAI,UAAJ,EAAgB;AACd,IAAA,IAAI,CAAC,MAAL,CACI,IAAI,IAAI,IADZ,EACkB,MAAM,gDADxB;AAEA,UAAM,KAAK,GAAG,eAAe,CAAC,IAAD,EAAO,MAAP,EAAe,eAAf,CAA7B;AACA,IAAA,MAAM,GAAG,MAAM,CAAC,GAAP,CAAW,GAAG,CAAC,GAAJ,CAAQ,GAAG,CAAC,MAAD,EAAS,KAAT,CAAX,CAAX,CAAT;AACD;;AACD,SAAO,EAAE,CAAC,GAAH,CAAO,MAAP,CAAP;AACD;;AAED,OAAO,MAAM,aAAa,GAAG,EAAE,CAAC;AAAC,EAAA;AAAD,CAAD,CAAxB","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { assertTypesMatch } from '../tensor_util';\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { op } from './operation';\nimport { pow } from './pow';\nimport { scalar } from './tensor_ops';\n/**\n * Compute the moving average of a variable.\n *\n * Without zeroDebias, the moving average operation is defined by:\n *   `v += delta`\n * where\n *   `delta = (1 - decay) * (x - v)`\n *\n * With zeroDebias (default), the `delta` term is scaled to debias the\n * effect of the (assumed) zero-initialization of `v`.\n *   `delta /= (1 - decay ^ step)`\n *\n * For more details on the zero-debiasing algorithm, see:\n *   https://arxiv.org/abs/1412.6980\n *\n * Note that this function is completely stateless and does not keep track of\n * step count. The step count needs to be maintained by the caller and passed\n * in as `step`.\n *\n * @param v The current moving average value.\n * @param x New input value, must have the same shape and dtype as `v`.\n * @param decay The decay factor. Typical values are 0.95 and 0.99.\n * @param step Step count.\n * @param zeroDebias: Whether zeroDebias is to be performed (default: `true`).\n * @returns The new moving average value.\n */\n/** @doc {heading: 'Operations', subheading: 'Moving Average'} */\nfunction movingAverage_(v, x, decay, step, zeroDebias = true) {\n    const $v = convertToTensor(v, 'v', 'movingAverage');\n    const $x = convertToTensor(x, 'x', 'movingAverage');\n    const $decay = convertToTensor(decay, 'decay', 'movingAverage');\n    assertTypesMatch($v, $x);\n    util.assert(util.arraysEqual($v.shape, $x.shape), () => 'Shape mismatch in v and x');\n    const one = scalar(1);\n    const oneMinusDecay = one.sub($decay);\n    let update = $x.sub($v).mul(oneMinusDecay);\n    if (zeroDebias) {\n        util.assert(step != null, () => 'When using zeroDebias: true, step is required.');\n        const $step = convertToTensor(step, 'step', 'movingAverage');\n        update = update.div(one.sub(pow($decay, $step)));\n    }\n    return $v.add(update);\n}\nexport const movingAverage = op({ movingAverage_ });\n//# sourceMappingURL=moving_average.js.map"]},"metadata":{},"sourceType":"module"}