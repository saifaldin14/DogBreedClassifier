{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { op } from '../ops/operation';\nimport { concat } from './concat';\nimport { fill } from './fill';\nimport { mul } from './mul';\nimport { slice } from './slice';\nimport { rfft } from './spectral_ops';\nimport { tensor1d, tensor2d } from './tensor_ops';\n/**\n * Generate a Hann window.\n *\n * See: https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows\n *\n * ```js\n * tf.signal.hannWindow(10).print();\n * ```\n * @param The length of window\n */\n\n/**\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\n */\n\nfunction hannWindow_(windowLength) {\n  return cosineWindow(windowLength, 0.5, 0.5);\n}\n/**\n * Generate a hamming window.\n *\n * See: https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows\n *\n * ```js\n * tf.signal.hammingWindow(10).print();\n * ```\n * @param The length of window\n */\n\n/**\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\n */\n\n\nfunction hammingWindow_(windowLength) {\n  return cosineWindow(windowLength, 0.54, 0.46);\n}\n/**\n * Expands input into frames of frameLength.\n * Slides a window size with frameStep.\n *\n * ```js\n * tf.signal.frame([1, 2, 3], 2, 1).print();\n * ```\n * @param signal The input tensor to be expanded\n * @param frameLength Length of each frame\n * @param frameStep The frame hop size in samples.\n * @param padEnd Whether to pad the end of signal with padValue.\n * @param padValue An number to use where the input signal does\n *     not exist when padEnd is True.\n */\n\n/**\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\n */\n\n\nfunction frame_(signal, frameLength, frameStep, padEnd = false, padValue = 0) {\n  let start = 0;\n  const output = [];\n\n  while (start + frameLength <= signal.size) {\n    output.push(slice(signal, start, frameLength));\n    start += frameStep;\n  }\n\n  if (padEnd) {\n    while (start < signal.size) {\n      const padLen = start + frameLength - signal.size;\n      const pad = concat([slice(signal, start, frameLength - padLen), fill([padLen], padValue)]);\n      output.push(pad);\n      start += frameStep;\n    }\n  }\n\n  if (output.length === 0) {\n    return tensor2d([], [0, frameLength]);\n  }\n\n  return concat(output).as2D(output.length, frameLength);\n}\n/**\n * Computes the Short-time Fourier Transform of signals\n * See: https://en.wikipedia.org/wiki/Short-time_Fourier_transform\n *\n * ```js\n * const input = tf.tensor1d([1, 1, 1, 1, 1])\n * tf.signal.stft(input, 3, 1).print();\n * ```\n * @param signal 1-dimensional real value tensor.\n * @param frameLength The window length of samples.\n * @param frameStep The number of samples to step.\n * @param fftLength The size of the FFT to apply.\n * @param windowFn A callable that takes a window length and returns 1-d tensor.\n */\n\n/**\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\n */\n\n\nfunction stft_(signal, frameLength, frameStep, fftLength, windowFn = hannWindow) {\n  if (fftLength == null) {\n    fftLength = enclosingPowerOfTwo(frameLength);\n  }\n\n  const framedSignal = frame(signal, frameLength, frameStep);\n  const windowedSignal = mul(framedSignal, windowFn(frameLength));\n  const output = [];\n\n  for (let i = 0; i < framedSignal.shape[0]; i++) {\n    output.push(rfft(windowedSignal.slice([i, 0], [1, frameLength]), fftLength));\n  }\n\n  return concat(output);\n}\n\nfunction enclosingPowerOfTwo(value) {\n  // Return 2**N for integer N such that 2**N >= value.\n  return Math.floor(Math.pow(2, Math.ceil(Math.log(value) / Math.log(2.0))));\n}\n\nfunction cosineWindow(windowLength, a, b) {\n  const even = 1 - windowLength % 2;\n  const newValues = new Float32Array(windowLength);\n\n  for (let i = 0; i < windowLength; ++i) {\n    const cosArg = 2.0 * Math.PI * i / (windowLength + even - 1);\n    newValues[i] = a - b * Math.cos(cosArg);\n  }\n\n  return tensor1d(newValues, 'float32');\n}\n\nexport const hannWindow = op({\n  hannWindow_\n});\nexport const hammingWindow = op({\n  hammingWindow_\n});\nexport const frame = op({\n  frame_\n});\nexport const stft = op({\n  stft_\n});","map":{"version":3,"sources":["../../src/ops/signal_ops.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAQ,EAAR,QAAiB,kBAAjB;AAGA,SAAQ,MAAR,QAAqB,UAArB;AACA,SAAQ,IAAR,QAAmB,QAAnB;AACA,SAAQ,GAAR,QAAkB,OAAlB;AACA,SAAQ,KAAR,QAAoB,SAApB;AACA,SAAQ,IAAR,QAAmB,gBAAnB;AACA,SAAQ,QAAR,EAAkB,QAAlB,QAAiC,cAAjC;AAEA;;;;;;;;;;;AAUA;;;;AAGA,SAAS,WAAT,CAAqB,YAArB,EAAyC;AACvC,SAAO,YAAY,CAAC,YAAD,EAAe,GAAf,EAAoB,GAApB,CAAnB;AACD;AAED;;;;;;;;;;;AAUA;;;;;AAGA,SAAS,cAAT,CAAwB,YAAxB,EAA4C;AAC1C,SAAO,YAAY,CAAC,YAAD,EAAe,IAAf,EAAqB,IAArB,CAAnB;AACD;AAED;;;;;;;;;;;;;;;AAcA;;;;;AAGA,SAAS,MAAT,CACI,MADJ,EACsB,WADtB,EAC2C,SAD3C,EAC8D,MAAM,GAAG,KADvE,EAEI,QAAQ,GAAG,CAFf,EAEgB;AACd,MAAI,KAAK,GAAG,CAAZ;AACA,QAAM,MAAM,GAAa,EAAzB;;AACA,SAAO,KAAK,GAAG,WAAR,IAAuB,MAAM,CAAC,IAArC,EAA2C;AACzC,IAAA,MAAM,CAAC,IAAP,CAAY,KAAK,CAAC,MAAD,EAAS,KAAT,EAAgB,WAAhB,CAAjB;AACA,IAAA,KAAK,IAAI,SAAT;AACD;;AAED,MAAI,MAAJ,EAAY;AACV,WAAO,KAAK,GAAG,MAAM,CAAC,IAAtB,EAA4B;AAC1B,YAAM,MAAM,GAAI,KAAK,GAAG,WAAT,GAAwB,MAAM,CAAC,IAA9C;AACA,YAAM,GAAG,GAAG,MAAM,CAAC,CACjB,KAAK,CAAC,MAAD,EAAS,KAAT,EAAgB,WAAW,GAAG,MAA9B,CADY,EAC2B,IAAI,CAAC,CAAC,MAAD,CAAD,EAAW,QAAX,CAD/B,CAAD,CAAlB;AAGA,MAAA,MAAM,CAAC,IAAP,CAAY,GAAZ;AACA,MAAA,KAAK,IAAI,SAAT;AACD;AACF;;AAED,MAAI,MAAM,CAAC,MAAP,KAAkB,CAAtB,EAAyB;AACvB,WAAO,QAAQ,CAAC,EAAD,EAAK,CAAC,CAAD,EAAI,WAAJ,CAAL,CAAf;AACD;;AAED,SAAO,MAAM,CAAC,MAAD,CAAN,CAAe,IAAf,CAAoB,MAAM,CAAC,MAA3B,EAAmC,WAAnC,CAAP;AACD;AAED;;;;;;;;;;;;;;;AAcA;;;;;AAGA,SAAS,KAAT,CACI,MADJ,EACsB,WADtB,EAC2C,SAD3C,EAEI,SAFJ,EAGI,QAAA,GAAyC,UAH7C,EAGuD;AACrD,MAAI,SAAS,IAAI,IAAjB,EAAuB;AACrB,IAAA,SAAS,GAAG,mBAAmB,CAAC,WAAD,CAA/B;AACD;;AACD,QAAM,YAAY,GAAG,KAAK,CAAC,MAAD,EAAS,WAAT,EAAsB,SAAtB,CAA1B;AACA,QAAM,cAAc,GAAG,GAAG,CAAC,YAAD,EAAe,QAAQ,CAAC,WAAD,CAAvB,CAA1B;AACA,QAAM,MAAM,GAAa,EAAzB;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,YAAY,CAAC,KAAb,CAAmB,CAAnB,CAApB,EAA2C,CAAC,EAA5C,EAAgD;AAC9C,IAAA,MAAM,CAAC,IAAP,CACI,IAAI,CAAC,cAAc,CAAC,KAAf,CAAqB,CAAC,CAAD,EAAI,CAAJ,CAArB,EAA6B,CAAC,CAAD,EAAI,WAAJ,CAA7B,CAAD,EAAiD,SAAjD,CADR;AAED;;AACD,SAAO,MAAM,CAAC,MAAD,CAAb;AACD;;AAED,SAAS,mBAAT,CAA6B,KAA7B,EAA0C;AACxC;AACA,SAAO,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,IAAI,CAAC,IAAL,CAAU,IAAI,CAAC,GAAL,CAAS,KAAT,IAAkB,IAAI,CAAC,GAAL,CAAS,GAAT,CAA5B,CAAZ,CAAX,CAAP;AACD;;AAED,SAAS,YAAT,CAAsB,YAAtB,EAA4C,CAA5C,EAAuD,CAAvD,EAAgE;AAC9D,QAAM,IAAI,GAAG,IAAI,YAAY,GAAG,CAAhC;AACA,QAAM,SAAS,GAAG,IAAI,YAAJ,CAAiB,YAAjB,CAAlB;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,YAApB,EAAkC,EAAE,CAApC,EAAuC;AACrC,UAAM,MAAM,GAAI,MAAM,IAAI,CAAC,EAAX,GAAgB,CAAjB,IAAuB,YAAY,GAAG,IAAf,GAAsB,CAA7C,CAAf;AACA,IAAA,SAAS,CAAC,CAAD,CAAT,GAAe,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAL,CAAS,MAAT,CAAvB;AACD;;AACD,SAAO,QAAQ,CAAC,SAAD,EAAY,SAAZ,CAAf;AACD;;AAED,OAAO,MAAM,UAAU,GAAG,EAAE,CAAC;AAAC,EAAA;AAAD,CAAD,CAArB;AACP,OAAO,MAAM,aAAa,GAAG,EAAE,CAAC;AAAC,EAAA;AAAD,CAAD,CAAxB;AACP,OAAO,MAAM,KAAK,GAAG,EAAE,CAAC;AAAC,EAAA;AAAD,CAAD,CAAhB;AACP,OAAO,MAAM,IAAI,GAAG,EAAE,CAAC;AAAC,EAAA;AAAD,CAAD,CAAf","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { op } from '../ops/operation';\nimport { concat } from './concat';\nimport { fill } from './fill';\nimport { mul } from './mul';\nimport { slice } from './slice';\nimport { rfft } from './spectral_ops';\nimport { tensor1d, tensor2d } from './tensor_ops';\n/**\n * Generate a Hann window.\n *\n * See: https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows\n *\n * ```js\n * tf.signal.hannWindow(10).print();\n * ```\n * @param The length of window\n */\n/**\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\n */\nfunction hannWindow_(windowLength) {\n    return cosineWindow(windowLength, 0.5, 0.5);\n}\n/**\n * Generate a hamming window.\n *\n * See: https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows\n *\n * ```js\n * tf.signal.hammingWindow(10).print();\n * ```\n * @param The length of window\n */\n/**\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\n */\nfunction hammingWindow_(windowLength) {\n    return cosineWindow(windowLength, 0.54, 0.46);\n}\n/**\n * Expands input into frames of frameLength.\n * Slides a window size with frameStep.\n *\n * ```js\n * tf.signal.frame([1, 2, 3], 2, 1).print();\n * ```\n * @param signal The input tensor to be expanded\n * @param frameLength Length of each frame\n * @param frameStep The frame hop size in samples.\n * @param padEnd Whether to pad the end of signal with padValue.\n * @param padValue An number to use where the input signal does\n *     not exist when padEnd is True.\n */\n/**\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\n */\nfunction frame_(signal, frameLength, frameStep, padEnd = false, padValue = 0) {\n    let start = 0;\n    const output = [];\n    while (start + frameLength <= signal.size) {\n        output.push(slice(signal, start, frameLength));\n        start += frameStep;\n    }\n    if (padEnd) {\n        while (start < signal.size) {\n            const padLen = (start + frameLength) - signal.size;\n            const pad = concat([\n                slice(signal, start, frameLength - padLen), fill([padLen], padValue)\n            ]);\n            output.push(pad);\n            start += frameStep;\n        }\n    }\n    if (output.length === 0) {\n        return tensor2d([], [0, frameLength]);\n    }\n    return concat(output).as2D(output.length, frameLength);\n}\n/**\n * Computes the Short-time Fourier Transform of signals\n * See: https://en.wikipedia.org/wiki/Short-time_Fourier_transform\n *\n * ```js\n * const input = tf.tensor1d([1, 1, 1, 1, 1])\n * tf.signal.stft(input, 3, 1).print();\n * ```\n * @param signal 1-dimensional real value tensor.\n * @param frameLength The window length of samples.\n * @param frameStep The number of samples to step.\n * @param fftLength The size of the FFT to apply.\n * @param windowFn A callable that takes a window length and returns 1-d tensor.\n */\n/**\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\n */\nfunction stft_(signal, frameLength, frameStep, fftLength, windowFn = hannWindow) {\n    if (fftLength == null) {\n        fftLength = enclosingPowerOfTwo(frameLength);\n    }\n    const framedSignal = frame(signal, frameLength, frameStep);\n    const windowedSignal = mul(framedSignal, windowFn(frameLength));\n    const output = [];\n    for (let i = 0; i < framedSignal.shape[0]; i++) {\n        output.push(rfft(windowedSignal.slice([i, 0], [1, frameLength]), fftLength));\n    }\n    return concat(output);\n}\nfunction enclosingPowerOfTwo(value) {\n    // Return 2**N for integer N such that 2**N >= value.\n    return Math.floor(Math.pow(2, Math.ceil(Math.log(value) / Math.log(2.0))));\n}\nfunction cosineWindow(windowLength, a, b) {\n    const even = 1 - windowLength % 2;\n    const newValues = new Float32Array(windowLength);\n    for (let i = 0; i < windowLength; ++i) {\n        const cosArg = (2.0 * Math.PI * i) / (windowLength + even - 1);\n        newValues[i] = a - b * Math.cos(cosArg);\n    }\n    return tensor1d(newValues, 'float32');\n}\nexport const hannWindow = op({ hannWindow_ });\nexport const hammingWindow = op({ hammingWindow_ });\nexport const frame = op({ frame_ });\nexport const stft = op({ stft_ });\n//# sourceMappingURL=signal_ops.js.map"]},"metadata":{},"sourceType":"module"}