{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { nonMaxSuppressionV3, nonMaxSuppressionV5 } from '../backends/non_max_suppression_impl';\nimport { ENGINE } from '../engine';\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { nonMaxSuppSanityCheck } from './nonmax_util';\nimport { op } from './operation';\nexport { nonMaxSuppression } from './non_max_suppression';\n/**\n * Bilinear resize a batch of 3D images to a new shape.\n *\n * @param images The images, of rank 4 or rank 3, of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param size The new shape `[newHeight, newWidth]` to resize the\n *     images to. Each channel is resized individually.\n * @param alignCorners Defaults to False. If true, rescale\n *     input by `(new_height - 1) / (height - 1)`, which exactly aligns the 4\n *     corners of images and resized images. If false, rescale by\n *     `new_height / height`. Treat similarly the width dimension.\n */\n\n/** @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'} */\n\nfunction resizeBilinear_(images, size, alignCorners = false) {\n  const $images = convertToTensor(images, 'images', 'resizeBilinear');\n  util.assert($images.rank === 3 || $images.rank === 4, () => `Error in resizeBilinear: x must be rank 3 or 4, but got ` + `rank ${$images.rank}.`);\n  util.assert(size.length === 2, () => `Error in resizeBilinear: new shape must 2D, but got shape ` + `${size}.`);\n  let batchImages = $images;\n  let reshapedTo4D = false;\n\n  if ($images.rank === 3) {\n    reshapedTo4D = true;\n    batchImages = $images.as4D(1, $images.shape[0], $images.shape[1], $images.shape[2]);\n  }\n\n  const [newHeight, newWidth] = size;\n\n  const forward = (backend, save) => {\n    save([batchImages]);\n    return backend.resizeBilinear(batchImages, newHeight, newWidth, alignCorners);\n  };\n\n  const backward = (dy, saved) => {\n    return {\n      x: () => ENGINE.runKernelFunc(backend => backend.resizeBilinearBackprop(dy, saved[0], alignCorners), {})\n    };\n  };\n\n  const res = ENGINE.runKernelFunc(forward, {\n    x: batchImages\n  }, backward, 'ResizeBilinear', {\n    alignCorners,\n    newHeight,\n    newWidth\n  });\n\n  if (reshapedTo4D) {\n    return res.as3D(res.shape[1], res.shape[2], res.shape[3]);\n  }\n\n  return res;\n}\n/**\n * NearestNeighbor resize a batch of 3D images to a new shape.\n *\n * @param images The images, of rank 4 or rank 3, of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param size The new shape `[newHeight, newWidth]` to resize the\n *     images to. Each channel is resized individually.\n * @param alignCorners Defaults to False. If true, rescale\n *     input by `(new_height - 1) / (height - 1)`, which exactly aligns the 4\n *     corners of images and resized images. If false, rescale by\n *     `new_height / height`. Treat similarly the width dimension.\n */\n\n/** @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'} */\n\n\nfunction resizeNearestNeighbor_(images, size, alignCorners = false) {\n  const $images = convertToTensor(images, 'images', 'resizeNearestNeighbor');\n  util.assert($images.rank === 3 || $images.rank === 4, () => `Error in resizeNearestNeighbor: x must be rank 3 or 4, but got ` + `rank ${$images.rank}.`);\n  util.assert(size.length === 2, () => `Error in resizeNearestNeighbor: new shape must 2D, but got shape ` + `${size}.`);\n  util.assert($images.dtype === 'float32' || $images.dtype === 'int32', () => '`images` must have `int32` or `float32` as dtype');\n  let batchImages = $images;\n  let reshapedTo4D = false;\n\n  if ($images.rank === 3) {\n    reshapedTo4D = true;\n    batchImages = $images.as4D(1, $images.shape[0], $images.shape[1], $images.shape[2]);\n  }\n\n  const [newHeight, newWidth] = size;\n\n  const forward = (backend, save) => {\n    save([batchImages]);\n    return backend.resizeNearestNeighbor(batchImages, newHeight, newWidth, alignCorners);\n  };\n\n  const backward = (dy, saved) => {\n    return {\n      batchImages: () => ENGINE.runKernelFunc(backend => backend.resizeNearestNeighborBackprop(dy, saved[0], alignCorners), {})\n    };\n  };\n\n  const res = ENGINE.runKernelFunc(forward, {\n    batchImages\n  }, backward);\n\n  if (reshapedTo4D) {\n    return res.as3D(res.shape[1], res.shape[2], res.shape[3]);\n  }\n\n  return res;\n}\n/**\n * Performs non maximum suppression of bounding boxes based on\n * iou (intersection over union).\n *\n * @param boxes a 2d tensor of shape `[numBoxes, 4]`. Each entry is\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of\n *     the bounding box.\n * @param scores a 1d tensor providing the box scores of shape `[numBoxes]`.\n * @param maxOutputSize The maximum number of boxes to be selected.\n * @param iouThreshold A float representing the threshold for deciding whether\n *     boxes overlap too much with respect to IOU. Must be between [0, 1].\n *     Defaults to 0.5 (50% box overlap).\n * @param scoreThreshold A threshold for deciding when to remove boxes based\n *     on score. Defaults to -inf, which means any score is accepted.\n * @return A 1D tensor with the selected box indices.\n */\n\n/** @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'} */\n\n/** This is the async version of `nonMaxSuppression` */\n\n\nasync function nonMaxSuppressionAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY) {\n  const $boxes = convertToTensor(boxes, 'boxes', 'nonMaxSuppressionAsync');\n  const $scores = convertToTensor(scores, 'scores', 'nonMaxSuppressionAsync');\n  const inputs = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);\n  maxOutputSize = inputs.maxOutputSize;\n  iouThreshold = inputs.iouThreshold;\n  scoreThreshold = inputs.scoreThreshold;\n  const boxesAndScores = await Promise.all([$boxes.data(), $scores.data()]);\n  const boxesVals = boxesAndScores[0];\n  const scoresVals = boxesAndScores[1];\n  const res = nonMaxSuppressionV3(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);\n\n  if ($boxes !== boxes) {\n    $boxes.dispose();\n  }\n\n  if ($scores !== scores) {\n    $scores.dispose();\n  }\n\n  return res;\n}\n/**\n * Performs non maximum suppression of bounding boxes based on\n * iou (intersection over union).\n *\n * This op also supports a Soft-NMS mode (c.f.\n * Bodla et al, https://arxiv.org/abs/1704.04503) where boxes reduce the score\n * of other overlapping boxes, therefore favoring different regions of the image\n * with high scores. To enable this Soft-NMS mode, set the `softNmsSigma`\n * parameter to be larger than 0.\n *\n * @param boxes a 2d tensor of shape `[numBoxes, 4]`. Each entry is\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of\n *     the bounding box.\n * @param scores a 1d tensor providing the box scores of shape `[numBoxes]`.\n * @param maxOutputSize The maximum number of boxes to be selected.\n * @param iouThreshold A float representing the threshold for deciding whether\n *     boxes overlap too much with respect to IOU. Must be between [0, 1].\n *     Defaults to 0.5 (50% box overlap).\n * @param scoreThreshold A threshold for deciding when to remove boxes based\n *     on score. Defaults to -inf, which means any score is accepted.\n * @param softNmsSigma A float representing the sigma parameter for Soft NMS.\n *     When sigma is 0, it falls back to nonMaxSuppression.\n * @return A map with the following properties:\n *     - selectedIndices: A 1D tensor with the selected box indices.\n *     - selectedScores: A 1D tensor with the corresponding scores for each\n *       selected box.\n */\n\n/** @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'} */\n\n\nfunction nonMaxSuppressionWithScore_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, softNmsSigma = 0.0) {\n  const $boxes = convertToTensor(boxes, 'boxes', 'nonMaxSuppression');\n  const $scores = convertToTensor(scores, 'scores', 'nonMaxSuppression');\n  const inputs = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);\n  maxOutputSize = inputs.maxOutputSize;\n  iouThreshold = inputs.iouThreshold;\n  scoreThreshold = inputs.scoreThreshold;\n  softNmsSigma = inputs.softNmsSigma;\n  const attrs = {\n    maxOutputSize,\n    iouThreshold,\n    scoreThreshold,\n    softNmsSigma\n  };\n  const result = ENGINE.runKernel('NonMaxSuppressionV5', {\n    boxes: $boxes,\n    scores: $scores\n  }, attrs);\n  return {\n    selectedIndices: result[0],\n    selectedScores: result[1]\n  };\n}\n/** This is the async version of `nonMaxSuppressionWithScore` */\n\n\nasync function nonMaxSuppressionWithScoreAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, softNmsSigma = 0.0) {\n  const $boxes = convertToTensor(boxes, 'boxes', 'nonMaxSuppressionAsync');\n  const $scores = convertToTensor(scores, 'scores', 'nonMaxSuppressionAsync');\n  const inputs = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);\n  maxOutputSize = inputs.maxOutputSize;\n  iouThreshold = inputs.iouThreshold;\n  scoreThreshold = inputs.scoreThreshold;\n  softNmsSigma = inputs.softNmsSigma;\n  const boxesAndScores = await Promise.all([$boxes.data(), $scores.data()]);\n  const boxesVals = boxesAndScores[0];\n  const scoresVals = boxesAndScores[1];\n  const res = nonMaxSuppressionV5(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);\n\n  if ($boxes !== boxes) {\n    $boxes.dispose();\n  }\n\n  if ($scores !== scores) {\n    $scores.dispose();\n  }\n\n  return res;\n}\n/**\n * Extracts crops from the input image tensor and resizes them using bilinear\n * sampling or nearest neighbor sampling (possibly with aspect ratio change)\n * to a common output size specified by crop_size.\n *\n * @param image 4d tensor of shape `[batch,imageHeight,imageWidth, depth]`,\n *     where imageHeight and imageWidth must be positive, specifying the\n *     batch of images from which to take crops\n * @param boxes 2d float32 tensor of shape `[numBoxes, 4]`. Each entry is\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the normalized\n *     coordinates of the box in the boxInd[i]'th image in the batch\n * @param boxInd 1d int32 tensor of shape `[numBoxes]` with values in range\n *     `[0, batch)` that specifies the image that the `i`-th box refers to.\n * @param cropSize 1d int32 tensor of 2 elements `[cropHeigh, cropWidth]`\n *     specifying the size to which all crops are resized to.\n * @param method Optional string from `'bilinear' | 'nearest'`,\n *     defaults to bilinear, which specifies the sampling method for resizing\n * @param extrapolationValue A threshold for deciding when to remove boxes based\n *     on score. Defaults to 0.\n * @return A 4D tensor of the shape `[numBoxes,cropHeight,cropWidth,depth]`\n */\n\n/** @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'} */\n\n\nfunction cropAndResize_(image, boxes, boxInd, cropSize, method, extrapolationValue) {\n  const $image = convertToTensor(image, 'image', 'cropAndResize');\n  const $boxes = convertToTensor(boxes, 'boxes', 'cropAndResize', 'float32');\n  const $boxInd = convertToTensor(boxInd, 'boxInd', 'cropAndResize', 'int32');\n  method = method || 'bilinear';\n  extrapolationValue = extrapolationValue || 0;\n  const numBoxes = $boxes.shape[0];\n  util.assert($image.rank === 4, () => 'Error in cropAndResize: image must be rank 4,' + `but got rank ${$image.rank}.`);\n  util.assert($boxes.rank === 2 && $boxes.shape[1] === 4, () => `Error in cropAndResize: boxes must be have size [${numBoxes},4] ` + `but had shape ${$boxes.shape}.`);\n  util.assert($boxInd.rank === 1 && $boxInd.shape[0] === numBoxes, () => `Error in cropAndResize: boxInd must be have size [${numBoxes}] ` + `but had shape ${$boxes.shape}.`);\n  util.assert(cropSize.length === 2, () => `Error in cropAndResize: cropSize must be of length 2, but got ` + `length ${cropSize.length}.`);\n  util.assert(cropSize[0] >= 1 && cropSize[1] >= 1, () => `cropSize must be atleast [1,1], but was ${cropSize}`);\n  util.assert(method === 'bilinear' || method === 'nearest', () => `method must be bilinear or nearest, but was ${method}`);\n\n  const forward = (backend, save) => backend.cropAndResize($image, $boxes, $boxInd, cropSize, method, extrapolationValue);\n\n  const res = ENGINE.runKernelFunc(forward, {\n    images: $image,\n    boxes: $boxes,\n    boxInd: $boxInd\n  }, null\n  /* der */\n  , 'CropAndResize', {\n    method,\n    extrapolationValue,\n    cropSize\n  });\n  return res;\n}\n\nexport const resizeBilinear = op({\n  resizeBilinear_\n});\nexport const resizeNearestNeighbor = op({\n  resizeNearestNeighbor_\n});\nexport const nonMaxSuppressionAsync = nonMaxSuppressionAsync_;\nexport const nonMaxSuppressionWithScore = op({\n  nonMaxSuppressionWithScore_\n});\nexport const nonMaxSuppressionWithScoreAsync = nonMaxSuppressionWithScoreAsync_;\nexport const cropAndResize = op({\n  cropAndResize_\n});","map":{"version":3,"sources":["../../src/ops/image_ops.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAQ,mBAAR,EAA6B,mBAA7B,QAAuD,sCAAvD;AACA,SAAQ,MAAR,QAAkC,WAAlC;AAGA,SAAQ,eAAR,QAA8B,oBAA9B;AAEA,OAAO,KAAK,IAAZ,MAAsB,SAAtB;AACA,SAAQ,qBAAR,QAAoC,eAApC;AAEA,SAAQ,EAAR,QAAiB,aAAjB;AACA,SAAQ,iBAAR,QAAgC,uBAAhC;AAEA;;;;;;;;;;;;;AAYA;;AACA,SAAS,eAAT,CACI,MADJ,EAC0B,IAD1B,EACkD,YAAY,GAAG,KADjE,EACsE;AACpE,QAAM,OAAO,GAAG,eAAe,CAAC,MAAD,EAAS,QAAT,EAAmB,gBAAnB,CAA/B;AACA,EAAA,IAAI,CAAC,MAAL,CACI,OAAO,CAAC,IAAR,KAAiB,CAAjB,IAAsB,OAAO,CAAC,IAAR,KAAiB,CAD3C,EAEI,MAAM,0DAAA,GACF,QAAQ,OAAO,CAAC,IAAI,GAH5B;AAIA,EAAA,IAAI,CAAC,MAAL,CACI,IAAI,CAAC,MAAL,KAAgB,CADpB,EAEI,MAAM,4DAAA,GACF,GAAG,IAAI,GAHf;AAKA,MAAI,WAAW,GAAG,OAAlB;AACA,MAAI,YAAY,GAAG,KAAnB;;AACA,MAAI,OAAO,CAAC,IAAR,KAAiB,CAArB,EAAwB;AACtB,IAAA,YAAY,GAAG,IAAf;AACA,IAAA,WAAW,GACP,OAAO,CAAC,IAAR,CAAa,CAAb,EAAgB,OAAO,CAAC,KAAR,CAAc,CAAd,CAAhB,EAAkC,OAAO,CAAC,KAAR,CAAc,CAAd,CAAlC,EAAoD,OAAO,CAAC,KAAR,CAAc,CAAd,CAApD,CADJ;AAED;;AAED,QAAM,CAAC,SAAD,EAAY,QAAZ,IAAwB,IAA9B;;AACA,QAAM,OAAO,GAA0B,CAAC,OAAD,EAAU,IAAV,KAAkB;AACvD,IAAA,IAAI,CAAC,CAAC,WAAD,CAAD,CAAJ;AACA,WAAO,OAAO,CAAC,cAAR,CACH,WADG,EACU,SADV,EACqB,QADrB,EAC+B,YAD/B,CAAP;AAED,GAJD;;AAMA,QAAM,QAAQ,GAAG,CAAC,EAAD,EAAe,KAAf,KAAkC;AACjD,WAAO;AACL,MAAA,CAAC,EAAE,MAAM,MAAM,CAAC,aAAP,CACL,OAAO,IAAI,OAAO,CAAC,sBAAR,CACP,EADO,EACH,KAAK,CAAC,CAAD,CADF,EACmB,YADnB,CADN,EAGL,EAHK;AADJ,KAAP;AAMD,GAPD;;AASA,QAAM,GAAG,GAAG,MAAM,CAAC,aAAP,CACR,OADQ,EACC;AAAC,IAAA,CAAC,EAAE;AAAJ,GADD,EACmB,QADnB,EAC6B,gBAD7B,EAER;AAAC,IAAA,YAAD;AAAe,IAAA,SAAf;AAA0B,IAAA;AAA1B,GAFQ,CAAZ;;AAGA,MAAI,YAAJ,EAAkB;AAChB,WAAO,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAT,EAAuB,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAvB,EAAqC,GAAG,CAAC,KAAJ,CAAU,CAAV,CAArC,CAAP;AACD;;AACD,SAAO,GAAP;AACD;AAED;;;;;;;;;;;;;AAYA;;;AACA,SAAS,sBAAT,CACI,MADJ,EAC0B,IAD1B,EACkD,YAAY,GAAG,KADjE,EACsE;AACpE,QAAM,OAAO,GAAG,eAAe,CAAC,MAAD,EAAS,QAAT,EAAmB,uBAAnB,CAA/B;AACA,EAAA,IAAI,CAAC,MAAL,CACI,OAAO,CAAC,IAAR,KAAiB,CAAjB,IAAsB,OAAO,CAAC,IAAR,KAAiB,CAD3C,EAEI,MAAM,iEAAA,GACF,QAAQ,OAAO,CAAC,IAAI,GAH5B;AAIA,EAAA,IAAI,CAAC,MAAL,CACI,IAAI,CAAC,MAAL,KAAgB,CADpB,EAEI,MACI,mEAAA,GACA,GAAG,IAAI,GAJf;AAKA,EAAA,IAAI,CAAC,MAAL,CACI,OAAO,CAAC,KAAR,KAAkB,SAAlB,IAA+B,OAAO,CAAC,KAAR,KAAkB,OADrD,EAEI,MAAM,kDAFV;AAIA,MAAI,WAAW,GAAG,OAAlB;AACA,MAAI,YAAY,GAAG,KAAnB;;AACA,MAAI,OAAO,CAAC,IAAR,KAAiB,CAArB,EAAwB;AACtB,IAAA,YAAY,GAAG,IAAf;AACA,IAAA,WAAW,GACP,OAAO,CAAC,IAAR,CAAa,CAAb,EAAgB,OAAO,CAAC,KAAR,CAAc,CAAd,CAAhB,EAAkC,OAAO,CAAC,KAAR,CAAc,CAAd,CAAlC,EAAoD,OAAO,CAAC,KAAR,CAAc,CAAd,CAApD,CADJ;AAED;;AACD,QAAM,CAAC,SAAD,EAAY,QAAZ,IAAwB,IAA9B;;AAEA,QAAM,OAAO,GAA0B,CAAC,OAAD,EAAU,IAAV,KAAkB;AACvD,IAAA,IAAI,CAAC,CAAC,WAAD,CAAD,CAAJ;AACA,WAAO,OAAO,CAAC,qBAAR,CACH,WADG,EACU,SADV,EACqB,QADrB,EAC+B,YAD/B,CAAP;AAED,GAJD;;AAMA,QAAM,QAAQ,GAAG,CAAC,EAAD,EAAe,KAAf,KAAkC;AACjD,WAAO;AACL,MAAA,WAAW,EAAE,MAAM,MAAM,CAAC,aAAP,CACf,OAAO,IAAI,OAAO,CAAC,6BAAR,CACP,EADO,EACH,KAAK,CAAC,CAAD,CADF,EACmB,YADnB,CADI,EAGf,EAHe;AADd,KAAP;AAMD,GAPD;;AASA,QAAM,GAAG,GAAG,MAAM,CAAC,aAAP,CAAqB,OAArB,EAA8B;AAAC,IAAA;AAAD,GAA9B,EAA6C,QAA7C,CAAZ;;AAEA,MAAI,YAAJ,EAAkB;AAChB,WAAO,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAT,EAAuB,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAvB,EAAqC,GAAG,CAAC,KAAJ,CAAU,CAAV,CAArC,CAAP;AACD;;AACD,SAAO,GAAP;AACD;AAED;;;;;;;;;;;;;;;;;AAgBA;;AACA;;;AACA,eAAe,uBAAf,CACI,KADJ,EACgC,MADhC,EAEI,aAFJ,EAE2B,YAAY,GAAG,GAF1C,EAGI,cAAc,GAAG,MAAM,CAAC,iBAH5B,EAG6C;AAC3C,QAAM,MAAM,GAAG,eAAe,CAAC,KAAD,EAAQ,OAAR,EAAiB,wBAAjB,CAA9B;AACA,QAAM,OAAO,GAAG,eAAe,CAAC,MAAD,EAAS,QAAT,EAAmB,wBAAnB,CAA/B;AAEA,QAAM,MAAM,GAAG,qBAAqB,CAChC,MADgC,EACxB,OADwB,EACf,aADe,EACA,YADA,EACc,cADd,CAApC;AAEA,EAAA,aAAa,GAAG,MAAM,CAAC,aAAvB;AACA,EAAA,YAAY,GAAG,MAAM,CAAC,YAAtB;AACA,EAAA,cAAc,GAAG,MAAM,CAAC,cAAxB;AAEA,QAAM,cAAc,GAAG,MAAM,OAAO,CAAC,GAAR,CAAY,CAAC,MAAM,CAAC,IAAP,EAAD,EAAgB,OAAO,CAAC,IAAR,EAAhB,CAAZ,CAA7B;AACA,QAAM,SAAS,GAAG,cAAc,CAAC,CAAD,CAAhC;AACA,QAAM,UAAU,GAAG,cAAc,CAAC,CAAD,CAAjC;AAEA,QAAM,GAAG,GAAG,mBAAmB,CAC3B,SAD2B,EAChB,UADgB,EACJ,aADI,EACW,YADX,EACyB,cADzB,CAA/B;;AAEA,MAAI,MAAM,KAAK,KAAf,EAAsB;AACpB,IAAA,MAAM,CAAC,OAAP;AACD;;AACD,MAAI,OAAO,KAAK,MAAhB,EAAwB;AACtB,IAAA,OAAO,CAAC,OAAR;AACD;;AACD,SAAO,GAAP;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA;;;AACA,SAAS,2BAAT,CACI,KADJ,EACgC,MADhC,EAEI,aAFJ,EAE2B,YAAY,GAAG,GAF1C,EAGI,cAAc,GAAG,MAAM,CAAC,iBAH5B,EAII,YAAY,GAAG,GAJnB,EAIsB;AACpB,QAAM,MAAM,GAAG,eAAe,CAAC,KAAD,EAAQ,OAAR,EAAiB,mBAAjB,CAA9B;AACA,QAAM,OAAO,GAAG,eAAe,CAAC,MAAD,EAAS,QAAT,EAAmB,mBAAnB,CAA/B;AAEA,QAAM,MAAM,GAAG,qBAAqB,CAChC,MADgC,EACxB,OADwB,EACf,aADe,EACA,YADA,EACc,cADd,EAEhC,YAFgC,CAApC;AAGA,EAAA,aAAa,GAAG,MAAM,CAAC,aAAvB;AACA,EAAA,YAAY,GAAG,MAAM,CAAC,YAAtB;AACA,EAAA,cAAc,GAAG,MAAM,CAAC,cAAxB;AACA,EAAA,YAAY,GAAG,MAAM,CAAC,YAAtB;AAEA,QAAM,KAAK,GAAG;AAAC,IAAA,aAAD;AAAgB,IAAA,YAAhB;AAA8B,IAAA,cAA9B;AAA8C,IAAA;AAA9C,GAAd;AAEA,QAAM,MAAM,GAAG,MAAM,CAAC,SAAP,CACI,qBADJ,EAC2B;AAAC,IAAA,KAAK,EAAE,MAAR;AAAgB,IAAA,MAAM,EAAE;AAAxB,GAD3B,EAEI,KAFJ,CAAf;AAIA,SAAO;AAAC,IAAA,eAAe,EAAE,MAAM,CAAC,CAAD,CAAxB;AAA6B,IAAA,cAAc,EAAE,MAAM,CAAC,CAAD;AAAnD,GAAP;AACD;AAED;;;AACA,eAAe,gCAAf,CACI,KADJ,EACgC,MADhC,EAEI,aAFJ,EAE2B,YAAY,GAAG,GAF1C,EAGI,cAAc,GAAG,MAAM,CAAC,iBAH5B,EAII,YAAY,GAAG,GAJnB,EAIsB;AACpB,QAAM,MAAM,GAAG,eAAe,CAAC,KAAD,EAAQ,OAAR,EAAiB,wBAAjB,CAA9B;AACA,QAAM,OAAO,GAAG,eAAe,CAAC,MAAD,EAAS,QAAT,EAAmB,wBAAnB,CAA/B;AAEA,QAAM,MAAM,GAAG,qBAAqB,CAChC,MADgC,EACxB,OADwB,EACf,aADe,EACA,YADA,EACc,cADd,EAEhC,YAFgC,CAApC;AAGA,EAAA,aAAa,GAAG,MAAM,CAAC,aAAvB;AACA,EAAA,YAAY,GAAG,MAAM,CAAC,YAAtB;AACA,EAAA,cAAc,GAAG,MAAM,CAAC,cAAxB;AACA,EAAA,YAAY,GAAG,MAAM,CAAC,YAAtB;AAEA,QAAM,cAAc,GAAG,MAAM,OAAO,CAAC,GAAR,CAAY,CAAC,MAAM,CAAC,IAAP,EAAD,EAAgB,OAAO,CAAC,IAAR,EAAhB,CAAZ,CAA7B;AACA,QAAM,SAAS,GAAG,cAAc,CAAC,CAAD,CAAhC;AACA,QAAM,UAAU,GAAG,cAAc,CAAC,CAAD,CAAjC;AAEA,QAAM,GAAG,GAAG,mBAAmB,CAC3B,SAD2B,EAChB,UADgB,EACJ,aADI,EACW,YADX,EACyB,cADzB,EAE3B,YAF2B,CAA/B;;AAIA,MAAI,MAAM,KAAK,KAAf,EAAsB;AACpB,IAAA,MAAM,CAAC,OAAP;AACD;;AACD,MAAI,OAAO,KAAK,MAAhB,EAAwB;AACtB,IAAA,OAAO,CAAC,OAAR;AACD;;AACD,SAAO,GAAP;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;AAqBA;;;AACA,SAAS,cAAT,CACI,KADJ,EAEI,KAFJ,EAGI,MAHJ,EAII,QAJJ,EAKI,MALJ,EAMI,kBANJ,EAM+B;AAE7B,QAAM,MAAM,GAAG,eAAe,CAAC,KAAD,EAAQ,OAAR,EAAiB,eAAjB,CAA9B;AACA,QAAM,MAAM,GAAG,eAAe,CAAC,KAAD,EAAQ,OAAR,EAAiB,eAAjB,EAAkC,SAAlC,CAA9B;AACA,QAAM,OAAO,GAAG,eAAe,CAAC,MAAD,EAAS,QAAT,EAAmB,eAAnB,EAAoC,OAApC,CAA/B;AACA,EAAA,MAAM,GAAG,MAAM,IAAI,UAAnB;AACA,EAAA,kBAAkB,GAAG,kBAAkB,IAAI,CAA3C;AAEA,QAAM,QAAQ,GAAG,MAAM,CAAC,KAAP,CAAa,CAAb,CAAjB;AAEA,EAAA,IAAI,CAAC,MAAL,CACI,MAAM,CAAC,IAAP,KAAgB,CADpB,EAEI,MAAM,kDACF,gBAAgB,MAAM,CAAC,IAAI,GAHnC;AAIA,EAAA,IAAI,CAAC,MAAL,CACI,MAAM,CAAC,IAAP,KAAgB,CAAhB,IAAqB,MAAM,CAAC,KAAP,CAAa,CAAb,MAAoB,CAD7C,EAEI,MAAM,oDAAoD,QAAQ,MAA5D,GACF,iBAAiB,MAAM,CAAC,KAAK,GAHrC;AAIA,EAAA,IAAI,CAAC,MAAL,CACI,OAAO,CAAC,IAAR,KAAiB,CAAjB,IAAsB,OAAO,CAAC,KAAR,CAAc,CAAd,MAAqB,QAD/C,EAEI,MAAM,qDAAqD,QAAQ,IAA7D,GACF,iBAAiB,MAAM,CAAC,KAAK,GAHrC;AAIA,EAAA,IAAI,CAAC,MAAL,CACI,QAAQ,CAAC,MAAT,KAAoB,CADxB,EAEI,MAAM,gEAAA,GACF,UAAU,QAAQ,CAAC,MAAM,GAHjC;AAIA,EAAA,IAAI,CAAC,MAAL,CACI,QAAQ,CAAC,CAAD,CAAR,IAAe,CAAf,IAAoB,QAAQ,CAAC,CAAD,CAAR,IAAe,CADvC,EAEI,MAAM,2CAA2C,QAAQ,EAF7D;AAGA,EAAA,IAAI,CAAC,MAAL,CACI,MAAM,KAAK,UAAX,IAAyB,MAAM,KAAK,SADxC,EAEI,MAAM,+CAA+C,MAAM,EAF/D;;AAIA,QAAM,OAAO,GAA0B,CAAC,OAAD,EAAU,IAAV,KACnC,OAAO,CAAC,aAAR,CACI,MADJ,EACY,MADZ,EACoB,OADpB,EAC6B,QAD7B,EACuC,MADvC,EAC+C,kBAD/C,CADJ;;AAIA,QAAM,GAAG,GAAG,MAAM,CAAC,aAAP,CACR,OADQ,EACC;AAAC,IAAA,MAAM,EAAE,MAAT;AAAiB,IAAA,KAAK,EAAE,MAAxB;AAAgC,IAAA,MAAM,EAAE;AAAxC,GADD,EACmD;AAAK;AADxD,IAER,eAFQ,EAES;AAAC,IAAA,MAAD;AAAS,IAAA,kBAAT;AAA6B,IAAA;AAA7B,GAFT,CAAZ;AAGA,SAAO,GAAP;AACD;;AAED,OAAO,MAAM,cAAc,GAAG,EAAE,CAAC;AAAC,EAAA;AAAD,CAAD,CAAzB;AACP,OAAO,MAAM,qBAAqB,GAAG,EAAE,CAAC;AAAC,EAAA;AAAD,CAAD,CAAhC;AACP,OAAO,MAAM,sBAAsB,GAAG,uBAA/B;AACP,OAAO,MAAM,0BAA0B,GAAG,EAAE,CAAC;AAAC,EAAA;AAAD,CAAD,CAArC;AACP,OAAO,MAAM,+BAA+B,GAAG,gCAAxC;AACP,OAAO,MAAM,aAAa,GAAG,EAAE,CAAC;AAAC,EAAA;AAAD,CAAD,CAAxB","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { nonMaxSuppressionV3, nonMaxSuppressionV5 } from '../backends/non_max_suppression_impl';\nimport { ENGINE } from '../engine';\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { nonMaxSuppSanityCheck } from './nonmax_util';\nimport { op } from './operation';\nexport { nonMaxSuppression } from './non_max_suppression';\n/**\n * Bilinear resize a batch of 3D images to a new shape.\n *\n * @param images The images, of rank 4 or rank 3, of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param size The new shape `[newHeight, newWidth]` to resize the\n *     images to. Each channel is resized individually.\n * @param alignCorners Defaults to False. If true, rescale\n *     input by `(new_height - 1) / (height - 1)`, which exactly aligns the 4\n *     corners of images and resized images. If false, rescale by\n *     `new_height / height`. Treat similarly the width dimension.\n */\n/** @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'} */\nfunction resizeBilinear_(images, size, alignCorners = false) {\n    const $images = convertToTensor(images, 'images', 'resizeBilinear');\n    util.assert($images.rank === 3 || $images.rank === 4, () => `Error in resizeBilinear: x must be rank 3 or 4, but got ` +\n        `rank ${$images.rank}.`);\n    util.assert(size.length === 2, () => `Error in resizeBilinear: new shape must 2D, but got shape ` +\n        `${size}.`);\n    let batchImages = $images;\n    let reshapedTo4D = false;\n    if ($images.rank === 3) {\n        reshapedTo4D = true;\n        batchImages =\n            $images.as4D(1, $images.shape[0], $images.shape[1], $images.shape[2]);\n    }\n    const [newHeight, newWidth] = size;\n    const forward = (backend, save) => {\n        save([batchImages]);\n        return backend.resizeBilinear(batchImages, newHeight, newWidth, alignCorners);\n    };\n    const backward = (dy, saved) => {\n        return {\n            x: () => ENGINE.runKernelFunc(backend => backend.resizeBilinearBackprop(dy, saved[0], alignCorners), {})\n        };\n    };\n    const res = ENGINE.runKernelFunc(forward, { x: batchImages }, backward, 'ResizeBilinear', { alignCorners, newHeight, newWidth });\n    if (reshapedTo4D) {\n        return res.as3D(res.shape[1], res.shape[2], res.shape[3]);\n    }\n    return res;\n}\n/**\n * NearestNeighbor resize a batch of 3D images to a new shape.\n *\n * @param images The images, of rank 4 or rank 3, of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param size The new shape `[newHeight, newWidth]` to resize the\n *     images to. Each channel is resized individually.\n * @param alignCorners Defaults to False. If true, rescale\n *     input by `(new_height - 1) / (height - 1)`, which exactly aligns the 4\n *     corners of images and resized images. If false, rescale by\n *     `new_height / height`. Treat similarly the width dimension.\n */\n/** @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'} */\nfunction resizeNearestNeighbor_(images, size, alignCorners = false) {\n    const $images = convertToTensor(images, 'images', 'resizeNearestNeighbor');\n    util.assert($images.rank === 3 || $images.rank === 4, () => `Error in resizeNearestNeighbor: x must be rank 3 or 4, but got ` +\n        `rank ${$images.rank}.`);\n    util.assert(size.length === 2, () => `Error in resizeNearestNeighbor: new shape must 2D, but got shape ` +\n        `${size}.`);\n    util.assert($images.dtype === 'float32' || $images.dtype === 'int32', () => '`images` must have `int32` or `float32` as dtype');\n    let batchImages = $images;\n    let reshapedTo4D = false;\n    if ($images.rank === 3) {\n        reshapedTo4D = true;\n        batchImages =\n            $images.as4D(1, $images.shape[0], $images.shape[1], $images.shape[2]);\n    }\n    const [newHeight, newWidth] = size;\n    const forward = (backend, save) => {\n        save([batchImages]);\n        return backend.resizeNearestNeighbor(batchImages, newHeight, newWidth, alignCorners);\n    };\n    const backward = (dy, saved) => {\n        return {\n            batchImages: () => ENGINE.runKernelFunc(backend => backend.resizeNearestNeighborBackprop(dy, saved[0], alignCorners), {})\n        };\n    };\n    const res = ENGINE.runKernelFunc(forward, { batchImages }, backward);\n    if (reshapedTo4D) {\n        return res.as3D(res.shape[1], res.shape[2], res.shape[3]);\n    }\n    return res;\n}\n/**\n * Performs non maximum suppression of bounding boxes based on\n * iou (intersection over union).\n *\n * @param boxes a 2d tensor of shape `[numBoxes, 4]`. Each entry is\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of\n *     the bounding box.\n * @param scores a 1d tensor providing the box scores of shape `[numBoxes]`.\n * @param maxOutputSize The maximum number of boxes to be selected.\n * @param iouThreshold A float representing the threshold for deciding whether\n *     boxes overlap too much with respect to IOU. Must be between [0, 1].\n *     Defaults to 0.5 (50% box overlap).\n * @param scoreThreshold A threshold for deciding when to remove boxes based\n *     on score. Defaults to -inf, which means any score is accepted.\n * @return A 1D tensor with the selected box indices.\n */\n/** @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'} */\n/** This is the async version of `nonMaxSuppression` */\nasync function nonMaxSuppressionAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY) {\n    const $boxes = convertToTensor(boxes, 'boxes', 'nonMaxSuppressionAsync');\n    const $scores = convertToTensor(scores, 'scores', 'nonMaxSuppressionAsync');\n    const inputs = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);\n    maxOutputSize = inputs.maxOutputSize;\n    iouThreshold = inputs.iouThreshold;\n    scoreThreshold = inputs.scoreThreshold;\n    const boxesAndScores = await Promise.all([$boxes.data(), $scores.data()]);\n    const boxesVals = boxesAndScores[0];\n    const scoresVals = boxesAndScores[1];\n    const res = nonMaxSuppressionV3(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);\n    if ($boxes !== boxes) {\n        $boxes.dispose();\n    }\n    if ($scores !== scores) {\n        $scores.dispose();\n    }\n    return res;\n}\n/**\n * Performs non maximum suppression of bounding boxes based on\n * iou (intersection over union).\n *\n * This op also supports a Soft-NMS mode (c.f.\n * Bodla et al, https://arxiv.org/abs/1704.04503) where boxes reduce the score\n * of other overlapping boxes, therefore favoring different regions of the image\n * with high scores. To enable this Soft-NMS mode, set the `softNmsSigma`\n * parameter to be larger than 0.\n *\n * @param boxes a 2d tensor of shape `[numBoxes, 4]`. Each entry is\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of\n *     the bounding box.\n * @param scores a 1d tensor providing the box scores of shape `[numBoxes]`.\n * @param maxOutputSize The maximum number of boxes to be selected.\n * @param iouThreshold A float representing the threshold for deciding whether\n *     boxes overlap too much with respect to IOU. Must be between [0, 1].\n *     Defaults to 0.5 (50% box overlap).\n * @param scoreThreshold A threshold for deciding when to remove boxes based\n *     on score. Defaults to -inf, which means any score is accepted.\n * @param softNmsSigma A float representing the sigma parameter for Soft NMS.\n *     When sigma is 0, it falls back to nonMaxSuppression.\n * @return A map with the following properties:\n *     - selectedIndices: A 1D tensor with the selected box indices.\n *     - selectedScores: A 1D tensor with the corresponding scores for each\n *       selected box.\n */\n/** @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'} */\nfunction nonMaxSuppressionWithScore_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, softNmsSigma = 0.0) {\n    const $boxes = convertToTensor(boxes, 'boxes', 'nonMaxSuppression');\n    const $scores = convertToTensor(scores, 'scores', 'nonMaxSuppression');\n    const inputs = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);\n    maxOutputSize = inputs.maxOutputSize;\n    iouThreshold = inputs.iouThreshold;\n    scoreThreshold = inputs.scoreThreshold;\n    softNmsSigma = inputs.softNmsSigma;\n    const attrs = { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma };\n    const result = ENGINE.runKernel('NonMaxSuppressionV5', { boxes: $boxes, scores: $scores }, attrs);\n    return { selectedIndices: result[0], selectedScores: result[1] };\n}\n/** This is the async version of `nonMaxSuppressionWithScore` */\nasync function nonMaxSuppressionWithScoreAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, softNmsSigma = 0.0) {\n    const $boxes = convertToTensor(boxes, 'boxes', 'nonMaxSuppressionAsync');\n    const $scores = convertToTensor(scores, 'scores', 'nonMaxSuppressionAsync');\n    const inputs = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);\n    maxOutputSize = inputs.maxOutputSize;\n    iouThreshold = inputs.iouThreshold;\n    scoreThreshold = inputs.scoreThreshold;\n    softNmsSigma = inputs.softNmsSigma;\n    const boxesAndScores = await Promise.all([$boxes.data(), $scores.data()]);\n    const boxesVals = boxesAndScores[0];\n    const scoresVals = boxesAndScores[1];\n    const res = nonMaxSuppressionV5(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);\n    if ($boxes !== boxes) {\n        $boxes.dispose();\n    }\n    if ($scores !== scores) {\n        $scores.dispose();\n    }\n    return res;\n}\n/**\n * Extracts crops from the input image tensor and resizes them using bilinear\n * sampling or nearest neighbor sampling (possibly with aspect ratio change)\n * to a common output size specified by crop_size.\n *\n * @param image 4d tensor of shape `[batch,imageHeight,imageWidth, depth]`,\n *     where imageHeight and imageWidth must be positive, specifying the\n *     batch of images from which to take crops\n * @param boxes 2d float32 tensor of shape `[numBoxes, 4]`. Each entry is\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the normalized\n *     coordinates of the box in the boxInd[i]'th image in the batch\n * @param boxInd 1d int32 tensor of shape `[numBoxes]` with values in range\n *     `[0, batch)` that specifies the image that the `i`-th box refers to.\n * @param cropSize 1d int32 tensor of 2 elements `[cropHeigh, cropWidth]`\n *     specifying the size to which all crops are resized to.\n * @param method Optional string from `'bilinear' | 'nearest'`,\n *     defaults to bilinear, which specifies the sampling method for resizing\n * @param extrapolationValue A threshold for deciding when to remove boxes based\n *     on score. Defaults to 0.\n * @return A 4D tensor of the shape `[numBoxes,cropHeight,cropWidth,depth]`\n */\n/** @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'} */\nfunction cropAndResize_(image, boxes, boxInd, cropSize, method, extrapolationValue) {\n    const $image = convertToTensor(image, 'image', 'cropAndResize');\n    const $boxes = convertToTensor(boxes, 'boxes', 'cropAndResize', 'float32');\n    const $boxInd = convertToTensor(boxInd, 'boxInd', 'cropAndResize', 'int32');\n    method = method || 'bilinear';\n    extrapolationValue = extrapolationValue || 0;\n    const numBoxes = $boxes.shape[0];\n    util.assert($image.rank === 4, () => 'Error in cropAndResize: image must be rank 4,' +\n        `but got rank ${$image.rank}.`);\n    util.assert($boxes.rank === 2 && $boxes.shape[1] === 4, () => `Error in cropAndResize: boxes must be have size [${numBoxes},4] ` +\n        `but had shape ${$boxes.shape}.`);\n    util.assert($boxInd.rank === 1 && $boxInd.shape[0] === numBoxes, () => `Error in cropAndResize: boxInd must be have size [${numBoxes}] ` +\n        `but had shape ${$boxes.shape}.`);\n    util.assert(cropSize.length === 2, () => `Error in cropAndResize: cropSize must be of length 2, but got ` +\n        `length ${cropSize.length}.`);\n    util.assert(cropSize[0] >= 1 && cropSize[1] >= 1, () => `cropSize must be atleast [1,1], but was ${cropSize}`);\n    util.assert(method === 'bilinear' || method === 'nearest', () => `method must be bilinear or nearest, but was ${method}`);\n    const forward = (backend, save) => backend.cropAndResize($image, $boxes, $boxInd, cropSize, method, extrapolationValue);\n    const res = ENGINE.runKernelFunc(forward, { images: $image, boxes: $boxes, boxInd: $boxInd }, null /* der */, 'CropAndResize', { method, extrapolationValue, cropSize });\n    return res;\n}\nexport const resizeBilinear = op({ resizeBilinear_ });\nexport const resizeNearestNeighbor = op({ resizeNearestNeighbor_ });\nexport const nonMaxSuppressionAsync = nonMaxSuppressionAsync_;\nexport const nonMaxSuppressionWithScore = op({ nonMaxSuppressionWithScore_ });\nexport const nonMaxSuppressionWithScoreAsync = nonMaxSuppressionWithScoreAsync_;\nexport const cropAndResize = op({ cropAndResize_ });\n//# sourceMappingURL=image_ops.js.map"]},"metadata":{},"sourceType":"module"}