{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nimport * as tex_util from './tex_util';\nimport * as webgl_util from './webgl_util';\nexport function createVertexShader(gl, debug) {\n  const glsl = getGlslDifferences();\n  const vertexShaderSource = `${glsl.version}\n    precision highp float;\n    ${glsl.attribute} vec3 clipSpacePos;\n    ${glsl.attribute} vec2 uv;\n    ${glsl.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;\n  return webgl_util.createVertexShader(gl, debug, vertexShaderSource);\n}\nexport function createVertexBuffer(gl, debug) {\n  // [x y z u v] * [upper-left, lower-left, upper-right, lower-right]\n  const vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);\n  return webgl_util.createStaticVertexBuffer(gl, debug, vertexArray);\n}\nexport function createIndexBuffer(gl, debug) {\n  // OpenGL (and WebGL) have \"CCW == front\" winding\n  const triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);\n  return webgl_util.createStaticIndexBuffer(gl, debug, triangleVertexIndices);\n}\n\nfunction createAndConfigureTexture(gl, debug, width, height, internalFormat, textureFormat, textureType) {\n  webgl_util.validateTextureSize(width, height);\n  const texture = webgl_util.createTexture(gl, debug);\n  const tex2d = gl.TEXTURE_2D;\n  webgl_util.callAndCheck(gl, debug, () => gl.bindTexture(tex2d, texture));\n  webgl_util.callAndCheck(gl, debug, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE));\n  webgl_util.callAndCheck(gl, debug, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE));\n  webgl_util.callAndCheck(gl, debug, () => gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST));\n  webgl_util.callAndCheck(gl, debug, () => gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST));\n  webgl_util.callAndCheck(gl, debug, () => gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, textureFormat, textureType, null));\n  webgl_util.callAndCheck(gl, debug, () => gl.bindTexture(gl.TEXTURE_2D, null));\n  return texture;\n}\n\nexport function createFloat32MatrixTexture(gl, debug, rows, columns, textureConfig) {\n  const [width, height] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(gl, debug, width, height, textureConfig.internalFormatFloat, textureConfig.textureFormatFloat, gl.FLOAT);\n}\nexport function createFloat16MatrixTexture(gl, debug, rows, columns, textureConfig) {\n  const [width, height] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(gl, debug, width, height, textureConfig.internalFormatHalfFloat, textureConfig.textureFormatFloat, textureConfig.textureTypeHalfFloat);\n}\nexport function createUnsignedBytesMatrixTexture(gl, debug, rows, columns, textureConfig) {\n  const [width, height] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(gl, debug, width, height, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE);\n}\nexport function createPackedMatrixTexture(gl, debug, rows, columns, textureConfig) {\n  const [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(gl, debug, width, height, textureConfig.internalFormatPackedFloat, gl.RGBA, gl.FLOAT);\n}\nexport function createFloat16PackedMatrixTexture(gl, debug, rows, columns, textureConfig) {\n  const [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(gl, debug, width, height, textureConfig.internalFormatPackedHalfFloat, gl.RGBA, textureConfig.textureTypeHalfFloat);\n}\nexport function bindVertexProgramAttributeStreams(gl, debug, program, vertexBuffer) {\n  const posOffset = 0; // x is the first buffer element\n\n  const uvOffset = 3 * 4; // uv comes after [x y z]\n\n  const stride = 3 * 4 + 2 * 4; // xyz + uv, each entry is 4-byte float.\n\n  webgl_util.callAndCheck(gl, debug, () => gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer));\n  const success = webgl_util.bindVertexBufferToProgramAttribute(gl, debug, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset);\n  return success && webgl_util.bindVertexBufferToProgramAttribute(gl, debug, program, 'uv', vertexBuffer, 2, stride, uvOffset);\n}\nexport function uploadDenseMatrixToTexture(gl, debug, texture, width, height, data, textureConfig) {\n  webgl_util.callAndCheck(gl, debug, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n  let dataForUpload, texelDataType, internalFormat;\n\n  if (data instanceof Uint8Array) {\n    dataForUpload = new Uint8Array(width * height * 4);\n    texelDataType = gl.UNSIGNED_BYTE;\n    internalFormat = gl.RGBA;\n  } else {\n    dataForUpload = new Float32Array(width * height * 4);\n    texelDataType = gl.FLOAT;\n    internalFormat = textureConfig.internalFormatPackedFloat;\n  }\n\n  dataForUpload.set(data);\n  webgl_util.callAndCheck(gl, debug, () => gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, gl.RGBA, texelDataType, dataForUpload));\n  webgl_util.callAndCheck(gl, debug, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\nexport function uploadPixelDataToTexture(gl, debug, texture, pixels) {\n  webgl_util.callAndCheck(gl, debug, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n\n  if (pixels.data instanceof Uint8Array) {\n    webgl_util.callAndCheck(gl, debug, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pixels.width, pixels.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels.data));\n  } else {\n    webgl_util.callAndCheck(gl, debug, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels));\n  }\n\n  webgl_util.callAndCheck(gl, debug, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\nexport function createBufferFromOutputTexture(gl2, debug, rows, columns, textureConfig) {\n  // Create and bind the buffer.\n  const buffer = gl2.createBuffer();\n  webgl_util.callAndCheck(gl2, debug, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer)); // Initialize the buffer to the size of the texture in bytes.\n\n  const bytesPerFloat = 4;\n  const valuesPerTexel = 4;\n  const bufferSizeBytes = bytesPerFloat * valuesPerTexel * rows * columns;\n  webgl_util.callAndCheck(gl2, debug, () => gl2.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl2.STREAM_READ)); // Enqueue a command on the GPU command queue to copy of texture into the\n  // buffer.\n\n  webgl_util.callAndCheck(gl2, debug, () => gl2.readPixels(0, 0, columns, rows, gl2.RGBA, gl2.FLOAT, 0));\n  webgl_util.callAndCheck(gl2, debug, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null));\n  return buffer;\n}\nexport function downloadFloat32MatrixFromBuffer(gl, buffer, size) {\n  const gl2 = gl;\n  const downloadTarget = new Float32Array(size);\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n  gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);\n  return downloadTarget;\n}\nexport function downloadByteEncodedFloatMatrixFromOutputTexture(gl, debug, rows, columns, textureConfig) {\n  const [w, h] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n  const numChannels = 4;\n  const downloadTarget = new Uint8Array(tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, numChannels));\n  webgl_util.callAndCheck(gl, debug, () => gl.readPixels(0, 0, w, h, textureConfig.downloadTextureFormat, gl.UNSIGNED_BYTE, downloadTarget)); // By wrapping the buffer in a Float32Array, we use native browser IEEE 754\n  // decoding of the 4 bytes that back each 32 bit float.\n\n  return new Float32Array(downloadTarget.buffer);\n}\nexport function downloadPackedMatrixFromBuffer(gl, buffer, batch, rows, cols, physicalRows, physicalCols, textureConfig) {\n  const gl2 = gl;\n  const downloadTarget = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(physicalRows, physicalCols));\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n  gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);\n  return downloadTarget;\n}\nexport function downloadMatrixFromPackedOutputTexture(gl, debug, physicalRows, physicalCols) {\n  const packedRGBA = new Float32Array(physicalRows * physicalCols * 4);\n  webgl_util.callAndCheck(gl, debug, () => gl.readPixels(0, 0, physicalCols, physicalRows, gl.RGBA, gl.FLOAT, packedRGBA));\n  return packedRGBA;\n}","map":{"version":3,"sources":["../src/gpgpu_util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nimport * as tex_util from './tex_util';\nimport * as webgl_util from './webgl_util';\nexport function createVertexShader(gl, debug) {\n    const glsl = getGlslDifferences();\n    const vertexShaderSource = `${glsl.version}\n    precision highp float;\n    ${glsl.attribute} vec3 clipSpacePos;\n    ${glsl.attribute} vec2 uv;\n    ${glsl.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;\n    return webgl_util.createVertexShader(gl, debug, vertexShaderSource);\n}\nexport function createVertexBuffer(gl, debug) {\n    // [x y z u v] * [upper-left, lower-left, upper-right, lower-right]\n    const vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);\n    return webgl_util.createStaticVertexBuffer(gl, debug, vertexArray);\n}\nexport function createIndexBuffer(gl, debug) {\n    // OpenGL (and WebGL) have \"CCW == front\" winding\n    const triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);\n    return webgl_util.createStaticIndexBuffer(gl, debug, triangleVertexIndices);\n}\nfunction createAndConfigureTexture(gl, debug, width, height, internalFormat, textureFormat, textureType) {\n    webgl_util.validateTextureSize(width, height);\n    const texture = webgl_util.createTexture(gl, debug);\n    const tex2d = gl.TEXTURE_2D;\n    webgl_util.callAndCheck(gl, debug, () => gl.bindTexture(tex2d, texture));\n    webgl_util.callAndCheck(gl, debug, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE));\n    webgl_util.callAndCheck(gl, debug, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE));\n    webgl_util.callAndCheck(gl, debug, () => gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST));\n    webgl_util.callAndCheck(gl, debug, () => gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST));\n    webgl_util.callAndCheck(gl, debug, () => gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, textureFormat, textureType, null));\n    webgl_util.callAndCheck(gl, debug, () => gl.bindTexture(gl.TEXTURE_2D, null));\n    return texture;\n}\nexport function createFloat32MatrixTexture(gl, debug, rows, columns, textureConfig) {\n    const [width, height] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n    return createAndConfigureTexture(gl, debug, width, height, textureConfig.internalFormatFloat, textureConfig.textureFormatFloat, gl.FLOAT);\n}\nexport function createFloat16MatrixTexture(gl, debug, rows, columns, textureConfig) {\n    const [width, height] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n    return createAndConfigureTexture(gl, debug, width, height, textureConfig.internalFormatHalfFloat, textureConfig.textureFormatFloat, textureConfig.textureTypeHalfFloat);\n}\nexport function createUnsignedBytesMatrixTexture(gl, debug, rows, columns, textureConfig) {\n    const [width, height] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n    return createAndConfigureTexture(gl, debug, width, height, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE);\n}\nexport function createPackedMatrixTexture(gl, debug, rows, columns, textureConfig) {\n    const [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n    return createAndConfigureTexture(gl, debug, width, height, textureConfig.internalFormatPackedFloat, gl.RGBA, gl.FLOAT);\n}\nexport function createFloat16PackedMatrixTexture(gl, debug, rows, columns, textureConfig) {\n    const [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n    return createAndConfigureTexture(gl, debug, width, height, textureConfig.internalFormatPackedHalfFloat, gl.RGBA, textureConfig.textureTypeHalfFloat);\n}\nexport function bindVertexProgramAttributeStreams(gl, debug, program, vertexBuffer) {\n    const posOffset = 0; // x is the first buffer element\n    const uvOffset = 3 * 4; // uv comes after [x y z]\n    const stride = (3 * 4) + (2 * 4); // xyz + uv, each entry is 4-byte float.\n    webgl_util.callAndCheck(gl, debug, () => gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer));\n    const success = webgl_util.bindVertexBufferToProgramAttribute(gl, debug, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset);\n    return success &&\n        webgl_util.bindVertexBufferToProgramAttribute(gl, debug, program, 'uv', vertexBuffer, 2, stride, uvOffset);\n}\nexport function uploadDenseMatrixToTexture(gl, debug, texture, width, height, data, textureConfig) {\n    webgl_util.callAndCheck(gl, debug, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n    let dataForUpload, texelDataType, internalFormat;\n    if (data instanceof Uint8Array) {\n        dataForUpload = new Uint8Array(width * height * 4);\n        texelDataType = gl.UNSIGNED_BYTE;\n        internalFormat = gl.RGBA;\n    }\n    else {\n        dataForUpload = new Float32Array(width * height * 4);\n        texelDataType = gl.FLOAT;\n        internalFormat = textureConfig.internalFormatPackedFloat;\n    }\n    dataForUpload.set(data);\n    webgl_util.callAndCheck(gl, debug, () => gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, gl.RGBA, texelDataType, dataForUpload));\n    webgl_util.callAndCheck(gl, debug, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\nexport function uploadPixelDataToTexture(gl, debug, texture, pixels) {\n    webgl_util.callAndCheck(gl, debug, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n    if (pixels.data instanceof Uint8Array) {\n        webgl_util.callAndCheck(gl, debug, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pixels.width, pixels.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels.data));\n    }\n    else {\n        webgl_util.callAndCheck(gl, debug, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels));\n    }\n    webgl_util.callAndCheck(gl, debug, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\nexport function createBufferFromOutputTexture(gl2, debug, rows, columns, textureConfig) {\n    // Create and bind the buffer.\n    const buffer = gl2.createBuffer();\n    webgl_util.callAndCheck(gl2, debug, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer));\n    // Initialize the buffer to the size of the texture in bytes.\n    const bytesPerFloat = 4;\n    const valuesPerTexel = 4;\n    const bufferSizeBytes = bytesPerFloat * valuesPerTexel * rows * columns;\n    webgl_util.callAndCheck(gl2, debug, () => gl2.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl2.STREAM_READ));\n    // Enqueue a command on the GPU command queue to copy of texture into the\n    // buffer.\n    webgl_util.callAndCheck(gl2, debug, () => gl2.readPixels(0, 0, columns, rows, gl2.RGBA, gl2.FLOAT, 0));\n    webgl_util.callAndCheck(gl2, debug, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null));\n    return buffer;\n}\nexport function downloadFloat32MatrixFromBuffer(gl, buffer, size) {\n    const gl2 = gl;\n    const downloadTarget = new Float32Array(size);\n    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n    gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);\n    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);\n    return downloadTarget;\n}\nexport function downloadByteEncodedFloatMatrixFromOutputTexture(gl, debug, rows, columns, textureConfig) {\n    const [w, h] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n    const numChannels = 4;\n    const downloadTarget = new Uint8Array(tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, numChannels));\n    webgl_util.callAndCheck(gl, debug, () => gl.readPixels(0, 0, w, h, textureConfig.downloadTextureFormat, gl.UNSIGNED_BYTE, downloadTarget));\n    // By wrapping the buffer in a Float32Array, we use native browser IEEE 754\n    // decoding of the 4 bytes that back each 32 bit float.\n    return new Float32Array(downloadTarget.buffer);\n}\nexport function downloadPackedMatrixFromBuffer(gl, buffer, batch, rows, cols, physicalRows, physicalCols, textureConfig) {\n    const gl2 = gl;\n    const downloadTarget = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(physicalRows, physicalCols));\n    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n    gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);\n    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);\n    return downloadTarget;\n}\nexport function downloadMatrixFromPackedOutputTexture(gl, debug, physicalRows, physicalCols) {\n    const packedRGBA = new Float32Array(physicalRows * physicalCols * 4);\n    webgl_util.callAndCheck(gl, debug, () => gl.readPixels(0, 0, physicalCols, physicalRows, gl.RGBA, gl.FLOAT, packedRGBA));\n    return packedRGBA;\n}\n//# sourceMappingURL=gpgpu_util.js.map"]},"metadata":{},"sourceType":"module"}