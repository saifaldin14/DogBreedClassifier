{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { convertToTensor } from '../tensor_util_env';\nimport { assert, isInt, parseAxisParam } from '../util';\nimport { expandDims } from './array_ops';\nimport { getUndoAxesPermutation } from './axis_util';\nimport { greaterEqual } from './greater_equal';\nimport { logicalAnd, where } from './logical_ops';\nimport { maximum } from './maximum';\nimport { op } from './operation';\nimport { collectGatherOpShapeInfo } from './segment_util';\nimport { ones, scalar, zerosLike } from './tensor_ops';\n/**\n * Computes the sum along segments of a `tf.Tensor`.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n * const segmentIds = tf.tensor1d([1, 2, 0, 1], 'int32');\n * const numSegments = 3;\n *\n * x.unsortedSegmentSum(segmentIds, numSegments).print()\n * //or tf.unsortedSegmentSum(x, segmentIds, numSegments)\n * ```\n * @param x The `tf.Tensor` that will be summed along its segments.\n * @param segmentIds A `tf.Tensor1D` whose rank is equal to the rank of `x`'s\n * dimension along the `axis`.  Maps each element of `x` to a segment.\n * @param numSegments The number of distinct `segmentIds`.\n */\n\n/** @doc {heading: 'Operations', subheading: 'Segment'} */\n\nfunction unsortedSegmentSum_(x, segmentIds, numSegments) {\n  const $x = convertToTensor(x, 'x', 'unsortedSegmentSum');\n  const $segmentIds = convertToTensor(segmentIds, 'segmentIds', 'unsortedSegmentSum', 'int32');\n  assert(isInt(numSegments), () => 'numSegments must be of dtype int');\n\n  const gradFunc = (dy, saved) => {\n    const [$segmentIds] = saved;\n\n    const derX = () => {\n      return gatherDropNegatives(dy, $segmentIds);\n    };\n\n    return {\n      $x: derX\n    };\n  };\n\n  return ENGINE.runKernelFunc((backend, save) => {\n    const res = backend.unsortedSegmentSum($x, $segmentIds, numSegments);\n    save([$segmentIds]);\n    return res;\n  }, {\n    $x\n  }, gradFunc);\n}\n/**\n * Gather slices from tensor `x`'s axis `axis` according to `indices`.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n * const indices = tf.tensor1d([1, 3, 3], 'int32');\n *\n * x.gather(indices).print();\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n * const indices = tf.tensor1d([1, 1, 0], 'int32');\n *\n * x.gather(indices).print();\n * ```\n * @param x The input tensor whose slices to be gathered.\n * @param indices The indices of the values to extract.\n * @param axis The axis over which to select values. Defaults to 0.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Slicing and Joining'} */\n\n\nfunction gather_(x, indices, axis = 0) {\n  const $x = convertToTensor(x, 'x', 'gather');\n  const $indices = convertToTensor(indices, 'indices', 'gather', 'int32');\n  axis = parseAxisParam(axis, $x.shape)[0];\n  const shapeInfo = collectGatherOpShapeInfo($x, $indices, axis);\n\n  const grad = (dy, saved) => {\n    const [$indices] = saved;\n\n    const derX = () => {\n      const paramsShape = $x.shape;\n      const indicesSize = $indices.size;\n      const outerShape = paramsShape.slice(0, axis);\n      const outerDims = outerShape.length;\n      const innerShape = paramsShape.slice(axis, paramsShape.length).slice(1);\n      const innerDims = innerShape.length;\n      const outerAxesIndices = arrayRange(0, outerDims);\n      const innerAxesIndices = arrayRange(outerDims + 1, outerDims + 1 + innerDims);\n      const valuesShape = arrayConcat([outerShape, [indicesSize], innerShape]);\n      const values = dy.reshape(valuesShape);\n      const reshapedIndices = $indices.reshape([indicesSize]);\n      const transposeDims = arrayConcat([[outerDims], outerAxesIndices, innerAxesIndices]);\n      const valuesTranspose = values.transpose(transposeDims);\n      let paramsGrad = unsortedSegmentSum(valuesTranspose, reshapedIndices, $x.shape[axis]);\n      const invertTransposeDims = getUndoAxesPermutation(transposeDims);\n      paramsGrad = paramsGrad.transpose(invertTransposeDims);\n      return paramsGrad;\n    };\n\n    return {\n      x: derX,\n      indices: () => $indices\n    };\n  };\n\n  return ENGINE.runKernelFunc((backend, save) => {\n    const res = backend.gather($x, $indices.flatten(), axis);\n    save([$indices]);\n    return res;\n  }, {\n    x: $x,\n    indices: $indices\n  }, grad, 'Gather', {\n    axis\n  }).reshape(shapeInfo.outputShape);\n}\n\nfunction arrayRange(start, stop) {\n  const result = [];\n\n  for (let i = start; i < stop; ++i) {\n    result.push(i);\n  }\n\n  return result;\n}\n\nfunction arrayConcat(arrays) {\n  const result = [];\n\n  for (let i = 0; i < arrays.length; ++i) {\n    for (let j = 0; j < arrays[i].length; ++j) {\n      result.push(arrays[i][j]);\n    }\n  }\n\n  return result;\n}\n\nfunction gatherDropNegatives(x, indices) {\n  // Helper function for unsorted segment ops. Gathers params for\n  // positive segment ids and gathers 0 for inputs with negative segment id.\n  // Mirrors _GatherDropNegatives from tensorflow/python/ops/math_grad.py\n  const zeroClippedIndices = maximum(indices, zerosLike(indices));\n  const gathered = gather(x, zeroClippedIndices);\n  let isPositive = greaterEqual(indices, scalar(0, 'int32'));\n  const numIters = gathered.rank - isPositive.rank;\n\n  for (let i = 0; i < numIters; ++i) {\n    isPositive = expandDims(isPositive, i + 1);\n  }\n\n  isPositive = logicalAnd(isPositive, ones(gathered.shape, 'bool'));\n  const zeroSlice = zerosLike(gathered);\n  return where(isPositive, gathered, zeroSlice);\n}\n\nexport const gather = op({\n  gather_\n});\nexport const unsortedSegmentSum = op({\n  unsortedSegmentSum_\n});","map":{"version":3,"sources":["../../src/ops/segment_ops.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { convertToTensor } from '../tensor_util_env';\nimport { assert, isInt, parseAxisParam } from '../util';\nimport { expandDims } from './array_ops';\nimport { getUndoAxesPermutation } from './axis_util';\nimport { greaterEqual } from './greater_equal';\nimport { logicalAnd, where } from './logical_ops';\nimport { maximum } from './maximum';\nimport { op } from './operation';\nimport { collectGatherOpShapeInfo } from './segment_util';\nimport { ones, scalar, zerosLike } from './tensor_ops';\n/**\n * Computes the sum along segments of a `tf.Tensor`.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n * const segmentIds = tf.tensor1d([1, 2, 0, 1], 'int32');\n * const numSegments = 3;\n *\n * x.unsortedSegmentSum(segmentIds, numSegments).print()\n * //or tf.unsortedSegmentSum(x, segmentIds, numSegments)\n * ```\n * @param x The `tf.Tensor` that will be summed along its segments.\n * @param segmentIds A `tf.Tensor1D` whose rank is equal to the rank of `x`'s\n * dimension along the `axis`.  Maps each element of `x` to a segment.\n * @param numSegments The number of distinct `segmentIds`.\n */\n/** @doc {heading: 'Operations', subheading: 'Segment'} */\nfunction unsortedSegmentSum_(x, segmentIds, numSegments) {\n    const $x = convertToTensor(x, 'x', 'unsortedSegmentSum');\n    const $segmentIds = convertToTensor(segmentIds, 'segmentIds', 'unsortedSegmentSum', 'int32');\n    assert(isInt(numSegments), () => 'numSegments must be of dtype int');\n    const gradFunc = (dy, saved) => {\n        const [$segmentIds] = saved;\n        const derX = () => {\n            return gatherDropNegatives(dy, $segmentIds);\n        };\n        return { $x: derX };\n    };\n    return ENGINE.runKernelFunc((backend, save) => {\n        const res = backend.unsortedSegmentSum($x, $segmentIds, numSegments);\n        save([$segmentIds]);\n        return res;\n    }, { $x }, gradFunc);\n}\n/**\n * Gather slices from tensor `x`'s axis `axis` according to `indices`.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n * const indices = tf.tensor1d([1, 3, 3], 'int32');\n *\n * x.gather(indices).print();\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n * const indices = tf.tensor1d([1, 1, 0], 'int32');\n *\n * x.gather(indices).print();\n * ```\n * @param x The input tensor whose slices to be gathered.\n * @param indices The indices of the values to extract.\n * @param axis The axis over which to select values. Defaults to 0.\n */\n/** @doc {heading: 'Tensors', subheading: 'Slicing and Joining'} */\nfunction gather_(x, indices, axis = 0) {\n    const $x = convertToTensor(x, 'x', 'gather');\n    const $indices = convertToTensor(indices, 'indices', 'gather', 'int32');\n    axis = parseAxisParam(axis, $x.shape)[0];\n    const shapeInfo = collectGatherOpShapeInfo($x, $indices, axis);\n    const grad = (dy, saved) => {\n        const [$indices] = saved;\n        const derX = () => {\n            const paramsShape = $x.shape;\n            const indicesSize = $indices.size;\n            const outerShape = paramsShape.slice(0, axis);\n            const outerDims = outerShape.length;\n            const innerShape = paramsShape.slice(axis, paramsShape.length).slice(1);\n            const innerDims = innerShape.length;\n            const outerAxesIndices = arrayRange(0, outerDims);\n            const innerAxesIndices = arrayRange(outerDims + 1, outerDims + 1 + innerDims);\n            const valuesShape = arrayConcat([outerShape, [indicesSize], innerShape]);\n            const values = dy.reshape(valuesShape);\n            const reshapedIndices = $indices.reshape([indicesSize]);\n            const transposeDims = arrayConcat([[outerDims], outerAxesIndices, innerAxesIndices]);\n            const valuesTranspose = values.transpose(transposeDims);\n            let paramsGrad = unsortedSegmentSum(valuesTranspose, reshapedIndices, $x.shape[axis]);\n            const invertTransposeDims = getUndoAxesPermutation(transposeDims);\n            paramsGrad = paramsGrad.transpose(invertTransposeDims);\n            return paramsGrad;\n        };\n        return { x: derX, indices: () => $indices };\n    };\n    return (ENGINE.runKernelFunc((backend, save) => {\n        const res = backend.gather($x, $indices.flatten(), axis);\n        save([$indices]);\n        return res;\n    }, { x: $x, indices: $indices }, grad, 'Gather', { axis }))\n        .reshape(shapeInfo.outputShape);\n}\nfunction arrayRange(start, stop) {\n    const result = [];\n    for (let i = start; i < stop; ++i) {\n        result.push(i);\n    }\n    return result;\n}\nfunction arrayConcat(arrays) {\n    const result = [];\n    for (let i = 0; i < arrays.length; ++i) {\n        for (let j = 0; j < arrays[i].length; ++j) {\n            result.push(arrays[i][j]);\n        }\n    }\n    return result;\n}\nfunction gatherDropNegatives(x, indices) {\n    // Helper function for unsorted segment ops. Gathers params for\n    // positive segment ids and gathers 0 for inputs with negative segment id.\n    // Mirrors _GatherDropNegatives from tensorflow/python/ops/math_grad.py\n    const zeroClippedIndices = maximum(indices, zerosLike(indices));\n    const gathered = gather(x, zeroClippedIndices);\n    let isPositive = greaterEqual(indices, scalar(0, 'int32'));\n    const numIters = gathered.rank - isPositive.rank;\n    for (let i = 0; i < numIters; ++i) {\n        isPositive = expandDims(isPositive, i + 1);\n    }\n    isPositive = logicalAnd(isPositive, ones(gathered.shape, 'bool'));\n    const zeroSlice = zerosLike(gathered);\n    return where(isPositive, gathered, zeroSlice);\n}\nexport const gather = op({ gather_ });\nexport const unsortedSegmentSum = op({ unsortedSegmentSum_ });\n//# sourceMappingURL=segment_ops.js.map"]},"metadata":{},"sourceType":"module"}