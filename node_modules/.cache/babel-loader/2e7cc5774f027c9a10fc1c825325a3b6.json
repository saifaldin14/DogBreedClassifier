{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { getParamValue } from './utils';\nexport const executeOp = (node, tensorMap, context) => {\n  switch (node.op) {\n    case 'ConcatV2':\n    case 'Concat':\n      {\n        const n = getParamValue('n', node, tensorMap, context);\n        const axis = getParamValue('axis', node, tensorMap, context);\n        let inputs = getParamValue('tensors', node, tensorMap, context);\n        inputs = inputs.slice(0, n);\n        return [tfc.concat(inputs, axis)];\n      }\n\n    case 'GatherV2':\n    case 'Gather':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const input = getParamValue('x', node, tensorMap, context);\n        const indices = getParamValue('indices', node, tensorMap, context);\n        return [tfc.gather(input, indices.asType('int32'), axis)];\n      }\n\n    case 'ReverseV2':\n    case 'Reverse':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const input = getParamValue('x', node, tensorMap, context);\n        return [tfc.reverse(input, axis)];\n      }\n\n    case 'Slice':\n      {\n        // tslint:disable-next-line:no-any\n        const begin = getParamValue('begin', node, tensorMap, context); // tslint:disable-next-line:no-any\n\n        const size = getParamValue('size', node, tensorMap, context);\n        return [tfc.slice(getParamValue('x', node, tensorMap, context), begin, size)];\n      }\n\n    case 'StridedSlice':\n      {\n        const begin = getParamValue('begin', node, tensorMap, context);\n        const end = getParamValue('end', node, tensorMap, context);\n        const strides = getParamValue('strides', node, tensorMap, context);\n        const beginMask = getParamValue('beginMask', node, tensorMap, context);\n        const endMask = getParamValue('endMask', node, tensorMap, context);\n        const ellipsisMask = getParamValue('ellipsisMask', node, tensorMap, context);\n        const newAxisMask = getParamValue('newAxisMask', node, tensorMap, context);\n        const shrinkAxisMask = getParamValue('shrinkAxisMask', node, tensorMap, context);\n        const tensor = getParamValue('x', node, tensorMap, context);\n\n        if (begin.length === 1 && tensor.shape.length > 1) {\n          for (let i = 1; i < tensor.shape.length; i++) {\n            begin.push(0);\n            end.push(tensor.shape[i]);\n            strides.push(strides[0]);\n          }\n        }\n\n        return [tfc.stridedSlice(tensor, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask)];\n      }\n\n    case 'Pack':\n      {\n        return tfc.tidy(() => {\n          const axis = getParamValue('axis', node, tensorMap, context);\n          const tensors = getParamValue('tensors', node, tensorMap, context); // Reshape the tensors to the first tensor's shape if they don't match.\n\n          const shape = tensors[0].shape;\n          const squeezedShape = tensors[0].squeeze().shape;\n          const mapped = tensors.map(tensor => {\n            const sameShape = tfc.util.arraysEqual(tensor.shape, shape);\n\n            if (!sameShape && !tfc.util.arraysEqual(tensor.squeeze().shape, squeezedShape)) {\n              throw new Error('the input tensors shape does not match');\n            }\n\n            return sameShape ? tensor : tensor.reshape(shape);\n          });\n          return [tfc.stack(mapped, axis)];\n        });\n      }\n\n    case 'Unpack':\n      {\n        return tfc.tidy(() => {\n          const axis = getParamValue('axis', node, tensorMap, context);\n          const tensor = getParamValue('tensor', node, tensorMap, context);\n          return tfc.unstack(tensor, axis);\n        });\n      }\n\n    case 'Tile':\n      {\n        const reps = getParamValue('reps', node, tensorMap, context);\n        return [tfc.tile(getParamValue('x', node, tensorMap, context), reps)];\n      }\n\n    case 'Split':\n    case 'SplitV':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const numOrSizeSplits = getParamValue('numOrSizeSplits', node, tensorMap, context);\n        return tfc.split(getParamValue('x', node, tensorMap, context), numOrSizeSplits, axis);\n      }\n\n    case 'ScatterNd':\n      {\n        const indices = getParamValue('indices', node, tensorMap, context);\n        const values = getParamValue('values', node, tensorMap, context);\n        const shape = getParamValue('shape', node, tensorMap, context);\n        return [tfc.scatterND(indices, values, shape)];\n      }\n\n    case 'GatherNd':\n      {\n        const x = getParamValue('x', node, tensorMap, context);\n        const indices = getParamValue('indices', node, tensorMap, context);\n        return [tfc.gatherND(x, indices)];\n      }\n\n    case 'SparseToDense':\n      {\n        const indices = getParamValue('sparseIndices', node, tensorMap, context);\n        const shape = getParamValue('outputShape', node, tensorMap, context);\n        const sparseValues = getParamValue('sparseValues', node, tensorMap, context);\n        const defaultValue = getParamValue('defaultValue', node, tensorMap, context);\n        return [tfc.sparseToDense(indices, sparseValues, shape, sparseValues.dtype === defaultValue.dtype ? defaultValue : defaultValue.asType(sparseValues.dtype))];\n      }\n\n    default:\n      throw TypeError(`Node type ${node.op} is not implemented`);\n  }\n};\nexport const CATEGORY = 'slice_join';","map":{"version":3,"sources":["../../../src/operations/executors/slice_join_executor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { getParamValue } from './utils';\nexport const executeOp = (node, tensorMap, context) => {\n    switch (node.op) {\n        case 'ConcatV2':\n        case 'Concat': {\n            const n = getParamValue('n', node, tensorMap, context);\n            const axis = getParamValue('axis', node, tensorMap, context);\n            let inputs = getParamValue('tensors', node, tensorMap, context);\n            inputs = inputs.slice(0, n);\n            return [tfc.concat(inputs, axis)];\n        }\n        case 'GatherV2':\n        case 'Gather': {\n            const axis = getParamValue('axis', node, tensorMap, context);\n            const input = getParamValue('x', node, tensorMap, context);\n            const indices = getParamValue('indices', node, tensorMap, context);\n            return [tfc.gather(input, indices.asType('int32'), axis)];\n        }\n        case 'ReverseV2':\n        case 'Reverse': {\n            const axis = getParamValue('axis', node, tensorMap, context);\n            const input = getParamValue('x', node, tensorMap, context);\n            return [tfc.reverse(input, axis)];\n        }\n        case 'Slice': {\n            // tslint:disable-next-line:no-any\n            const begin = getParamValue('begin', node, tensorMap, context);\n            // tslint:disable-next-line:no-any\n            const size = getParamValue('size', node, tensorMap, context);\n            return [tfc.slice(getParamValue('x', node, tensorMap, context), begin, size)];\n        }\n        case 'StridedSlice': {\n            const begin = getParamValue('begin', node, tensorMap, context);\n            const end = getParamValue('end', node, tensorMap, context);\n            const strides = getParamValue('strides', node, tensorMap, context);\n            const beginMask = getParamValue('beginMask', node, tensorMap, context);\n            const endMask = getParamValue('endMask', node, tensorMap, context);\n            const ellipsisMask = getParamValue('ellipsisMask', node, tensorMap, context);\n            const newAxisMask = getParamValue('newAxisMask', node, tensorMap, context);\n            const shrinkAxisMask = getParamValue('shrinkAxisMask', node, tensorMap, context);\n            const tensor = getParamValue('x', node, tensorMap, context);\n            if (begin.length === 1 && tensor.shape.length > 1) {\n                for (let i = 1; i < tensor.shape.length; i++) {\n                    begin.push(0);\n                    end.push(tensor.shape[i]);\n                    strides.push(strides[0]);\n                }\n            }\n            return [tfc.stridedSlice(tensor, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask)];\n        }\n        case 'Pack': {\n            return tfc.tidy(() => {\n                const axis = getParamValue('axis', node, tensorMap, context);\n                const tensors = getParamValue('tensors', node, tensorMap, context);\n                // Reshape the tensors to the first tensor's shape if they don't match.\n                const shape = tensors[0].shape;\n                const squeezedShape = tensors[0].squeeze().shape;\n                const mapped = tensors.map(tensor => {\n                    const sameShape = tfc.util.arraysEqual(tensor.shape, shape);\n                    if (!sameShape &&\n                        !tfc.util.arraysEqual(tensor.squeeze().shape, squeezedShape)) {\n                        throw new Error('the input tensors shape does not match');\n                    }\n                    return sameShape ? tensor : tensor.reshape(shape);\n                });\n                return [tfc.stack(mapped, axis)];\n            });\n        }\n        case 'Unpack': {\n            return tfc.tidy(() => {\n                const axis = getParamValue('axis', node, tensorMap, context);\n                const tensor = getParamValue('tensor', node, tensorMap, context);\n                return tfc.unstack(tensor, axis);\n            });\n        }\n        case 'Tile': {\n            const reps = getParamValue('reps', node, tensorMap, context);\n            return [tfc.tile(getParamValue('x', node, tensorMap, context), reps)];\n        }\n        case 'Split':\n        case 'SplitV': {\n            const axis = getParamValue('axis', node, tensorMap, context);\n            const numOrSizeSplits = getParamValue('numOrSizeSplits', node, tensorMap, context);\n            return tfc.split(getParamValue('x', node, tensorMap, context), numOrSizeSplits, axis);\n        }\n        case 'ScatterNd': {\n            const indices = getParamValue('indices', node, tensorMap, context);\n            const values = getParamValue('values', node, tensorMap, context);\n            const shape = getParamValue('shape', node, tensorMap, context);\n            return [tfc.scatterND(indices, values, shape)];\n        }\n        case 'GatherNd': {\n            const x = getParamValue('x', node, tensorMap, context);\n            const indices = getParamValue('indices', node, tensorMap, context);\n            return [tfc.gatherND(x, indices)];\n        }\n        case 'SparseToDense': {\n            const indices = getParamValue('sparseIndices', node, tensorMap, context);\n            const shape = getParamValue('outputShape', node, tensorMap, context);\n            const sparseValues = getParamValue('sparseValues', node, tensorMap, context);\n            const defaultValue = getParamValue('defaultValue', node, tensorMap, context);\n            return [tfc.sparseToDense(indices, sparseValues, shape, sparseValues.dtype === defaultValue.dtype ?\n                    defaultValue :\n                    defaultValue.asType(sparseValues.dtype))];\n        }\n        default:\n            throw TypeError(`Node type ${node.op} is not implemented`);\n    }\n};\nexport const CATEGORY = 'slice_join';\n//# sourceMappingURL=slice_join_executor.js.map"]},"metadata":{},"sourceType":"module"}