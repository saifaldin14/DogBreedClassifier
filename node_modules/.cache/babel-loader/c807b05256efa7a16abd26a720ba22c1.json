{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport { PhysicalTextureType, TextureUsage } from './tex_util';\nexport class TextureManager {\n  constructor(gpgpu) {\n    this.gpgpu = gpgpu;\n    this.numUsedTextures = 0;\n    this.numFreeTextures = 0;\n    this.freeTextures = {};\n    this.logEnabled = false;\n    this.usedTextures = {};\n  }\n\n  acquireTexture(shapeRC, usage, isPacked) {\n    const physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);\n    const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);\n\n    if (!(shapeKey in this.freeTextures)) {\n      this.freeTextures[shapeKey] = [];\n    }\n\n    if (!(shapeKey in this.usedTextures)) {\n      this.usedTextures[shapeKey] = [];\n    }\n\n    if (this.freeTextures[shapeKey].length > 0) {\n      this.numFreeTextures--;\n      this.numUsedTextures++;\n      this.log();\n      const newTexture = this.freeTextures[shapeKey].shift();\n      this.usedTextures[shapeKey].push(newTexture);\n      return newTexture;\n    }\n\n    this.numUsedTextures++;\n    this.log();\n    let newTexture;\n\n    if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {\n      newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {\n      newTexture = this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {\n      newTexture = this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {\n      newTexture = this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {\n      newTexture = this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);\n    }\n\n    this.usedTextures[shapeKey].push(newTexture);\n    return newTexture;\n  }\n\n  releaseTexture(texture, shape, logicalTexType, isPacked) {\n    if (this.freeTextures == null) {\n      // Already disposed.\n      return;\n    }\n\n    const physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType, isPacked);\n    const shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);\n\n    if (!(shapeKey in this.freeTextures)) {\n      this.freeTextures[shapeKey] = [];\n    }\n\n    this.freeTextures[shapeKey].push(texture);\n    this.numFreeTextures++;\n    this.numUsedTextures--;\n    const texList = this.usedTextures[shapeKey];\n    const texIndex = texList.indexOf(texture);\n\n    if (texIndex < 0) {\n      throw new Error('Cannot release a texture that was never provided by this ' + 'texture manager');\n    }\n\n    texList.splice(texIndex, 1);\n    this.log();\n  }\n\n  log() {\n    if (!this.logEnabled) {\n      return;\n    }\n\n    const total = this.numFreeTextures + this.numUsedTextures;\n    console.log('Free/Used', `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${total})`);\n  }\n\n  getNumUsedTextures() {\n    return this.numUsedTextures;\n  }\n\n  getNumFreeTextures() {\n    return this.numFreeTextures;\n  }\n\n  dispose() {\n    if (this.freeTextures == null) {\n      // Already disposed.\n      return;\n    }\n\n    for (const texShape in this.freeTextures) {\n      this.freeTextures[texShape].forEach(tex => {\n        this.gpgpu.deleteMatrixTexture(tex);\n      });\n    }\n\n    for (const texShape in this.usedTextures) {\n      this.usedTextures[texShape].forEach(tex => {\n        this.gpgpu.deleteMatrixTexture(tex);\n      });\n    }\n\n    this.freeTextures = null;\n    this.usedTextures = null;\n    this.numUsedTextures = 0;\n    this.numFreeTextures = 0;\n  }\n\n}\n\nfunction getPhysicalTextureForRendering(isPacked) {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED')) {\n    if (isPacked) {\n      return PhysicalTextureType.PACKED_2X2_FLOAT32;\n    }\n\n    return PhysicalTextureType.UNPACKED_FLOAT32;\n  }\n\n  if (isPacked) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT16;\n  }\n\n  return PhysicalTextureType.UNPACKED_FLOAT16;\n}\n\nfunction getPhysicalFromLogicalTextureType(logicalTexType, isPacked) {\n  if (logicalTexType === TextureUsage.UPLOAD) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT32;\n  } else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {\n    return getPhysicalTextureForRendering(isPacked);\n  } else if (logicalTexType === TextureUsage.DOWNLOAD || logicalTexType === TextureUsage.PIXELS) {\n    return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;\n  }\n\n  throw new Error(`Unknown logical texture type ${logicalTexType}`);\n}\n\nfunction getKeyFromTextureShape(shapeRowsCol, physicalTexType, isPacked) {\n  return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;\n}","map":{"version":3,"sources":["../src/texture_manager.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport { PhysicalTextureType, TextureUsage } from './tex_util';\nexport class TextureManager {\n    constructor(gpgpu) {\n        this.gpgpu = gpgpu;\n        this.numUsedTextures = 0;\n        this.numFreeTextures = 0;\n        this.freeTextures = {};\n        this.logEnabled = false;\n        this.usedTextures = {};\n    }\n    acquireTexture(shapeRC, usage, isPacked) {\n        const physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);\n        const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);\n        if (!(shapeKey in this.freeTextures)) {\n            this.freeTextures[shapeKey] = [];\n        }\n        if (!(shapeKey in this.usedTextures)) {\n            this.usedTextures[shapeKey] = [];\n        }\n        if (this.freeTextures[shapeKey].length > 0) {\n            this.numFreeTextures--;\n            this.numUsedTextures++;\n            this.log();\n            const newTexture = this.freeTextures[shapeKey].shift();\n            this.usedTextures[shapeKey].push(newTexture);\n            return newTexture;\n        }\n        this.numUsedTextures++;\n        this.log();\n        let newTexture;\n        if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {\n            newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {\n            newTexture =\n                this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {\n            newTexture =\n                this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {\n            newTexture =\n                this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {\n            newTexture =\n                this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        this.usedTextures[shapeKey].push(newTexture);\n        return newTexture;\n    }\n    releaseTexture(texture, shape, logicalTexType, isPacked) {\n        if (this.freeTextures == null) {\n            // Already disposed.\n            return;\n        }\n        const physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType, isPacked);\n        const shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);\n        if (!(shapeKey in this.freeTextures)) {\n            this.freeTextures[shapeKey] = [];\n        }\n        this.freeTextures[shapeKey].push(texture);\n        this.numFreeTextures++;\n        this.numUsedTextures--;\n        const texList = this.usedTextures[shapeKey];\n        const texIndex = texList.indexOf(texture);\n        if (texIndex < 0) {\n            throw new Error('Cannot release a texture that was never provided by this ' +\n                'texture manager');\n        }\n        texList.splice(texIndex, 1);\n        this.log();\n    }\n    log() {\n        if (!this.logEnabled) {\n            return;\n        }\n        const total = this.numFreeTextures + this.numUsedTextures;\n        console.log('Free/Used', `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${total})`);\n    }\n    getNumUsedTextures() {\n        return this.numUsedTextures;\n    }\n    getNumFreeTextures() {\n        return this.numFreeTextures;\n    }\n    dispose() {\n        if (this.freeTextures == null) {\n            // Already disposed.\n            return;\n        }\n        for (const texShape in this.freeTextures) {\n            this.freeTextures[texShape].forEach(tex => {\n                this.gpgpu.deleteMatrixTexture(tex);\n            });\n        }\n        for (const texShape in this.usedTextures) {\n            this.usedTextures[texShape].forEach(tex => {\n                this.gpgpu.deleteMatrixTexture(tex);\n            });\n        }\n        this.freeTextures = null;\n        this.usedTextures = null;\n        this.numUsedTextures = 0;\n        this.numFreeTextures = 0;\n    }\n}\nfunction getPhysicalTextureForRendering(isPacked) {\n    if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED')) {\n        if (isPacked) {\n            return PhysicalTextureType.PACKED_2X2_FLOAT32;\n        }\n        return PhysicalTextureType.UNPACKED_FLOAT32;\n    }\n    if (isPacked) {\n        return PhysicalTextureType.PACKED_2X2_FLOAT16;\n    }\n    return PhysicalTextureType.UNPACKED_FLOAT16;\n}\nfunction getPhysicalFromLogicalTextureType(logicalTexType, isPacked) {\n    if (logicalTexType === TextureUsage.UPLOAD) {\n        return PhysicalTextureType.PACKED_2X2_FLOAT32;\n    }\n    else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {\n        return getPhysicalTextureForRendering(isPacked);\n    }\n    else if (logicalTexType === TextureUsage.DOWNLOAD ||\n        logicalTexType === TextureUsage.PIXELS) {\n        return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;\n    }\n    throw new Error(`Unknown logical texture type ${logicalTexType}`);\n}\nfunction getKeyFromTextureShape(shapeRowsCol, physicalTexType, isPacked) {\n    return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;\n}\n//# sourceMappingURL=texture_manager.js.map"]},"metadata":{},"sourceType":"module"}