{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { op } from './operation';\nimport { pad } from './pad';\nimport * as slice_util from './slice_util';\n/**\n * Extracts a 1D slice from 1D array starting at coordinates `begin` and is\n * of length `size`. See `slice` for details.\n */\n\nfunction slice1d_(x, begin, size) {\n  const $x = convertToTensor(x, 'x', 'slice1d');\n  util.assert($x.rank === 1, () => `slice1d expects a rank-1 tensor, but got a rank-${$x.rank} tensor`);\n  return slice($x, [begin], [size]);\n}\n/**\n * Extracts a 2D slice from a 2D array starting at coordinates `begin` and\n * is of size `size`. See `slice` for details.\n */\n\n\nfunction slice2d_(x, begin, size) {\n  const $x = convertToTensor(x, 'x', 'slice2d');\n  util.assert($x.rank === 2, () => `slice2d expects a rank-2 tensor, but got a rank-${$x.rank} tensor`);\n  return slice($x, begin, size);\n}\n/**\n * Extracts a 3D slice from a 3D array starting at coordinates `begin` and\n * is of size `size`. See `slice` for details.\n */\n\n\nfunction slice3d_(x, begin, size) {\n  const $x = convertToTensor(x, 'x', 'slice3d');\n  util.assert($x.rank === 3, () => `slice3d expects a rank-3 tensor, but got a rank-${$x.rank} tensor`);\n  return slice($x, begin, size);\n}\n/**\n * Extracts a 4D slice from a 4D array starting at coordinates `begin` and\n * is of size `size`. See `slice` for details.\n */\n\n\nfunction slice4d_(x, begin, size) {\n  const $x = convertToTensor(x, 'x', 'slice4d');\n  util.assert($x.rank === 4, () => `slice4d expects a rank-4 tensor, but got a rank-${$x.rank} tensor`);\n  return slice($x, begin, size);\n}\n/**\n * Extracts a slice from a `tf.Tensor` starting at coordinates `begin`\n * and is of size `size`.\n *\n * Also available are stricter rank-specific methods with the same signature\n * as this method that assert that `x` is of the given rank:\n *   - `tf.slice1d`\n *   - `tf.slice2d`\n *   - `tf.slice3d`\n *   - `tf.slice4d`\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n *\n * x.slice([1], [2]).print();\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * x.slice([1, 0], [1, 2]).print();\n * ```\n * @param x The input `tf.Tensor` to slice from.\n * @param begin The coordinates to start the slice from. The length can be\n *     less than the rank of x - the rest of the axes will have implicit 0 as\n *     start. Can also be a single number, in which case it specifies the\n *     first axis.\n * @param size The size of the slice. The length can be less than the rank of\n *     x - the rest of the axes will have implicit -1. A value of -1 requests\n *     the rest of the dimensions in the axis. Can also be a single number,\n *     in which case it specifies the size of the first axis.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Slicing and Joining'} */\n\n\nfunction slice_(x, begin, size) {\n  const $x = convertToTensor(x, 'x', 'slice');\n\n  if ($x.rank === 0) {\n    throw new Error('Slicing scalar is not possible');\n  } // The following logic allows for more ergonomic calls.\n\n\n  let begin_;\n\n  if (typeof begin === 'number') {\n    begin_ = [begin, ...new Array($x.rank - 1).fill(0)];\n  } else if (begin.length < $x.rank) {\n    begin_ = begin.concat(new Array($x.rank - begin.length).fill(0));\n  } else {\n    begin_ = begin.slice();\n  }\n\n  begin_.forEach(d => {\n    util.assert(d !== -1, () => 'slice() does not support negative begin indexing.');\n  });\n  let size_;\n\n  if (size == null) {\n    size_ = new Array($x.rank).fill(-1);\n  } else if (typeof size === 'number') {\n    size_ = [size, ...new Array($x.rank - 1).fill(-1)];\n  } else if (size.length < $x.rank) {\n    size_ = size.concat(new Array($x.rank - size.length).fill(-1));\n  } else {\n    size_ = size;\n  }\n\n  size_ = size_.map((d, i) => {\n    if (d >= 0) {\n      return d;\n    } else {\n      util.assert(d === -1, () => `Negative size values should be exactly -1 but got ` + `${d} for the slice() size at index ${i}.`);\n      return $x.shape[i] - begin_[i];\n    }\n  });\n  slice_util.assertParamsValid($x, begin_, size_);\n  const inputShape = $x.shape;\n\n  const grad = dy => {\n    // Create an Nx2 padding where the first column represents how many\n    // zeros are prepended (at start) for each dimension, and the second\n    // column indicates how many zeros are appended (at end).\n    // The number of zeros to append is the shape of the input\n    // elementwise-subtracted by both the begin vector and sizes vector.\n    const paddings = [];\n\n    for (let i = 0; i < dy.rank; i++) {\n      paddings.push([begin_[i], inputShape[i] - begin_[i] - size_[i]]);\n    }\n\n    return {\n      x: () => pad(dy, paddings)\n    };\n  };\n\n  const attrs = {\n    begin: begin_,\n    size: size_\n  };\n  return ENGINE.runKernelFunc(backend => backend.slice($x, begin_, size_), {\n    x: $x\n  }, grad, 'Slice', attrs);\n}\n\nexport const slice = op({\n  slice_\n});\nexport const slice1d = op({\n  slice1d_\n});\nexport const slice2d = op({\n  slice2d_\n});\nexport const slice3d = op({\n  slice3d_\n});\nexport const slice4d = op({\n  slice4d_\n});","map":{"version":3,"sources":["../../src/ops/slice.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { op } from './operation';\nimport { pad } from './pad';\nimport * as slice_util from './slice_util';\n/**\n * Extracts a 1D slice from 1D array starting at coordinates `begin` and is\n * of length `size`. See `slice` for details.\n */\nfunction slice1d_(x, begin, size) {\n    const $x = convertToTensor(x, 'x', 'slice1d');\n    util.assert($x.rank === 1, () => `slice1d expects a rank-1 tensor, but got a rank-${$x.rank} tensor`);\n    return slice($x, [begin], [size]);\n}\n/**\n * Extracts a 2D slice from a 2D array starting at coordinates `begin` and\n * is of size `size`. See `slice` for details.\n */\nfunction slice2d_(x, begin, size) {\n    const $x = convertToTensor(x, 'x', 'slice2d');\n    util.assert($x.rank === 2, () => `slice2d expects a rank-2 tensor, but got a rank-${$x.rank} tensor`);\n    return slice($x, begin, size);\n}\n/**\n * Extracts a 3D slice from a 3D array starting at coordinates `begin` and\n * is of size `size`. See `slice` for details.\n */\nfunction slice3d_(x, begin, size) {\n    const $x = convertToTensor(x, 'x', 'slice3d');\n    util.assert($x.rank === 3, () => `slice3d expects a rank-3 tensor, but got a rank-${$x.rank} tensor`);\n    return slice($x, begin, size);\n}\n/**\n * Extracts a 4D slice from a 4D array starting at coordinates `begin` and\n * is of size `size`. See `slice` for details.\n */\nfunction slice4d_(x, begin, size) {\n    const $x = convertToTensor(x, 'x', 'slice4d');\n    util.assert($x.rank === 4, () => `slice4d expects a rank-4 tensor, but got a rank-${$x.rank} tensor`);\n    return slice($x, begin, size);\n}\n/**\n * Extracts a slice from a `tf.Tensor` starting at coordinates `begin`\n * and is of size `size`.\n *\n * Also available are stricter rank-specific methods with the same signature\n * as this method that assert that `x` is of the given rank:\n *   - `tf.slice1d`\n *   - `tf.slice2d`\n *   - `tf.slice3d`\n *   - `tf.slice4d`\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n *\n * x.slice([1], [2]).print();\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * x.slice([1, 0], [1, 2]).print();\n * ```\n * @param x The input `tf.Tensor` to slice from.\n * @param begin The coordinates to start the slice from. The length can be\n *     less than the rank of x - the rest of the axes will have implicit 0 as\n *     start. Can also be a single number, in which case it specifies the\n *     first axis.\n * @param size The size of the slice. The length can be less than the rank of\n *     x - the rest of the axes will have implicit -1. A value of -1 requests\n *     the rest of the dimensions in the axis. Can also be a single number,\n *     in which case it specifies the size of the first axis.\n */\n/** @doc {heading: 'Tensors', subheading: 'Slicing and Joining'} */\nfunction slice_(x, begin, size) {\n    const $x = convertToTensor(x, 'x', 'slice');\n    if ($x.rank === 0) {\n        throw new Error('Slicing scalar is not possible');\n    }\n    // The following logic allows for more ergonomic calls.\n    let begin_;\n    if (typeof begin === 'number') {\n        begin_ = [begin, ...new Array($x.rank - 1).fill(0)];\n    }\n    else if (begin.length < $x.rank) {\n        begin_ = begin.concat(new Array($x.rank - begin.length).fill(0));\n    }\n    else {\n        begin_ = begin.slice();\n    }\n    begin_.forEach(d => {\n        util.assert(d !== -1, () => 'slice() does not support negative begin indexing.');\n    });\n    let size_;\n    if (size == null) {\n        size_ = new Array($x.rank).fill(-1);\n    }\n    else if (typeof size === 'number') {\n        size_ = [size, ...new Array($x.rank - 1).fill(-1)];\n    }\n    else if (size.length < $x.rank) {\n        size_ = size.concat(new Array($x.rank - size.length).fill(-1));\n    }\n    else {\n        size_ = size;\n    }\n    size_ = size_.map((d, i) => {\n        if (d >= 0) {\n            return d;\n        }\n        else {\n            util.assert(d === -1, () => `Negative size values should be exactly -1 but got ` +\n                `${d} for the slice() size at index ${i}.`);\n            return $x.shape[i] - begin_[i];\n        }\n    });\n    slice_util.assertParamsValid($x, begin_, size_);\n    const inputShape = $x.shape;\n    const grad = (dy) => {\n        // Create an Nx2 padding where the first column represents how many\n        // zeros are prepended (at start) for each dimension, and the second\n        // column indicates how many zeros are appended (at end).\n        // The number of zeros to append is the shape of the input\n        // elementwise-subtracted by both the begin vector and sizes vector.\n        const paddings = [];\n        for (let i = 0; i < dy.rank; i++) {\n            paddings.push([begin_[i], inputShape[i] - begin_[i] - size_[i]]);\n        }\n        return { x: () => pad(dy, paddings) };\n    };\n    const attrs = { begin: begin_, size: size_ };\n    return ENGINE.runKernelFunc(backend => backend.slice($x, begin_, size_), { x: $x }, grad, 'Slice', attrs);\n}\nexport const slice = op({ slice_ });\nexport const slice1d = op({ slice1d_ });\nexport const slice2d = op({ slice2d_ });\nexport const slice3d = op({ slice3d_ });\nexport const slice4d = op({ slice4d_ });\n//# sourceMappingURL=slice.js.map"]},"metadata":{},"sourceType":"module"}