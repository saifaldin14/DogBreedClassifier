{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { env } from '../environment';\nimport { convertToTensor, inferShape } from '../tensor_util_env';\nimport { assert, assertNonNegativeIntegerDimensions, assertNonNull, flatten, inferDtype, isTypedArray, makeOnesTypedArray, makeZerosTypedArray, sizeFromShape, toTypedArray } from '../util';\nimport { complex } from './complex';\nimport { imag } from './imag';\nimport { op } from './operation';\nimport { real } from './real';\n/**\n * Creates a `tf.Tensor` with the provided values, shape and dtype.\n *\n * ```js\n * // Pass an array of values to create a vector.\n * tf.tensor([1, 2, 3, 4]).print();\n * ```\n *\n * ```js\n * // Pass a nested array of values to make a matrix or a higher\n * // dimensional tensor.\n * tf.tensor([[1, 2], [3, 4]]).print();\n * ```\n *\n * ```js\n * // Pass a flat array and specify a shape yourself.\n * tf.tensor([1, 2, 3, 4], [2, 2]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`. If the values are strings,\n *     they will be encoded as utf-8 and kept as `Uint8Array[]`.\n * @param shape The shape of the tensor. Optional. If not provided,\n *   it is inferred from `values`.\n * @param dtype The data type.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\nfunction tensor(values, shape, dtype) {\n  const inferredShape = inferShape(values, dtype);\n  return makeTensor(values, shape, inferredShape, dtype);\n}\n/** This is shared code across all tensor creation methods. */\n\n\nfunction makeTensor(values, shape, inferredShape, dtype) {\n  if (dtype == null) {\n    dtype = inferDtype(values);\n  }\n\n  if (dtype === 'complex64') {\n    throw new Error(`Cannot construct a complex64 tensor directly. ` + `Please use tf.complex(real, imag).`);\n  }\n\n  if (!isTypedArray(values) && !Array.isArray(values) && typeof values !== 'number' && typeof values !== 'boolean' && typeof values !== 'string') {\n    throw new Error('values passed to tensor(values) must be a number/boolean/string or ' + 'an array of numbers/booleans/strings, or a TypedArray');\n  }\n\n  if (shape != null) {\n    assertNonNegativeIntegerDimensions(shape);\n    const providedSize = sizeFromShape(shape);\n    const inferredSize = sizeFromShape(inferredShape);\n    assert(providedSize === inferredSize, () => `Based on the provided shape, [${shape}], the tensor should have ` + `${providedSize} values but has ${inferredSize}`);\n\n    for (let i = 0; i < inferredShape.length; ++i) {\n      const inferred = inferredShape[i];\n      const flatDimsDontMatch = i === inferredShape.length - 1 ? inferred !== sizeFromShape(shape.slice(i)) : true;\n      assert(inferredShape[i] === shape[i] || !flatDimsDontMatch, () => `Error creating a new Tensor. Inferred shape ` + `(${inferredShape}) does not match the provided ` + `shape (${shape}). `);\n    }\n  }\n\n  if (!isTypedArray(values) && !Array.isArray(values)) {\n    values = [values];\n  }\n\n  shape = shape || inferredShape;\n  values = dtype !== 'string' ? toTypedArray(values, dtype, env().getBool('DEBUG')) : flatten(values, [], true);\n  return ENGINE.makeTensor(values, shape, dtype);\n}\n/**\n * Creates rank-0 `tf.Tensor` (scalar) with the provided value and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.scalar` as it makes the code more readable.\n *\n * ```js\n * tf.scalar(3.14).print();\n * ```\n *\n * @param value The value of the scalar.\n * @param dtype The data type.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\n\nfunction scalar(value, dtype) {\n  if ((isTypedArray(value) && dtype !== 'string' || Array.isArray(value)) && dtype !== 'complex64') {\n    throw new Error('Error creating a new Scalar: value must be a primitive ' + '(number|boolean|string)');\n  }\n\n  if (dtype === 'string' && isTypedArray(value) && !(value instanceof Uint8Array)) {\n    throw new Error('When making a scalar from encoded string, ' + 'the value must be `Uint8Array`.');\n  }\n\n  const shape = [];\n  const inferredShape = [];\n  return makeTensor(value, shape, inferredShape, dtype);\n}\n/**\n * Creates rank-1 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor1d` as it makes the code more readable.\n *\n * ```js\n * tf.tensor1d([1, 2, 3]).print();\n * ```\n *\n * @param values The values of the tensor. Can be array of numbers,\n *     or a `TypedArray`.\n * @param dtype The data type.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\n\nfunction tensor1d(values, dtype) {\n  assertNonNull(values);\n  const inferredShape = inferShape(values, dtype);\n\n  if (inferredShape.length !== 1) {\n    throw new Error('tensor1d() requires values to be a flat/TypedArray');\n  }\n\n  const shape = null;\n  return makeTensor(values, shape, inferredShape, dtype);\n}\n/**\n * Creates rank-2 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor2d` as it makes the code more readable.\n *\n *  ```js\n * // Pass a nested array.\n * tf.tensor2d([[1, 2], [3, 4]]).print();\n * ```\n * ```js\n * // Pass a flat array and specify a shape.\n * tf.tensor2d([1, 2, 3, 4], [2, 2]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`.\n * @param shape The shape of the tensor. If not provided, it is inferred from\n *     `values`.\n * @param dtype The data type.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\n\nfunction tensor2d(values, shape, dtype) {\n  assertNonNull(values);\n\n  if (shape != null && shape.length !== 2) {\n    throw new Error('tensor2d() requires shape to have two numbers');\n  }\n\n  const inferredShape = inferShape(values, dtype);\n\n  if (inferredShape.length !== 2 && inferredShape.length !== 1) {\n    throw new Error('tensor2d() requires values to be number[][] or flat/TypedArray');\n  }\n\n  if (inferredShape.length === 1 && shape == null) {\n    throw new Error('tensor2d() requires shape to be provided when `values` ' + 'are a flat/TypedArray');\n  }\n\n  return makeTensor(values, shape, inferredShape, dtype);\n}\n/**\n * Creates rank-3 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor3d` as it makes the code more readable.\n *\n *  ```js\n * // Pass a nested array.\n * tf.tensor3d([[[1], [2]], [[3], [4]]]).print();\n * ```\n * ```js\n * // Pass a flat array and specify a shape.\n * tf.tensor3d([1, 2, 3, 4], [2, 2, 1]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`.\n * @param shape The shape of the tensor. If not provided,  it is inferred from\n *     `values`.\n * @param dtype The data type.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\n\nfunction tensor3d(values, shape, dtype) {\n  assertNonNull(values);\n\n  if (shape != null && shape.length !== 3) {\n    throw new Error('tensor3d() requires shape to have three numbers');\n  }\n\n  const inferredShape = inferShape(values, dtype);\n\n  if (inferredShape.length !== 3 && inferredShape.length !== 1) {\n    throw new Error('tensor3d() requires values to be number[][][] or flat/TypedArray');\n  }\n\n  if (inferredShape.length === 1 && shape == null) {\n    throw new Error('tensor3d() requires shape to be provided when `values` ' + 'are a flat array');\n  }\n\n  return makeTensor(values, shape, inferredShape, dtype);\n}\n/**\n * Creates rank-4 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor4d` as it makes the code more readable.\n *\n *  ```js\n * // Pass a nested array.\n * tf.tensor4d([[[[1], [2]], [[3], [4]]]]).print();\n * ```\n * ```js\n * // Pass a flat array and specify a shape.\n * tf.tensor4d([1, 2, 3, 4], [1, 2, 2, 1]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`.\n * @param shape The shape of the tensor. Optional. If not provided,\n *   it is inferred from `values`.\n * @param dtype The data type.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\n\nfunction tensor4d(values, shape, dtype) {\n  assertNonNull(values);\n\n  if (shape != null && shape.length !== 4) {\n    throw new Error('tensor4d() requires shape to have four numbers');\n  }\n\n  const inferredShape = inferShape(values, dtype);\n\n  if (inferredShape.length !== 4 && inferredShape.length !== 1) {\n    throw new Error('tensor4d() requires values to be number[][][][] or flat/TypedArray');\n  }\n\n  if (inferredShape.length === 1 && shape == null) {\n    throw new Error('tensor4d() requires shape to be provided when `values` ' + 'are a flat array');\n  }\n\n  return makeTensor(values, shape, inferredShape, dtype);\n}\n/**\n * Creates rank-5 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor5d` as it makes the code more readable.\n *\n *  ```js\n * // Pass a nested array.\n * tf.tensor5d([[[[[1], [2]], [[3], [4]]]]]).print();\n * ```\n * ```js\n * // Pass a flat array and specify a shape.\n * tf.tensor5d([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 2, 2, 1]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`.\n * @param shape The shape of the tensor. Optional. If not provided,\n *   it is inferred from `values`.\n * @param dtype The data type.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\n\nfunction tensor5d(values, shape, dtype) {\n  assertNonNull(values);\n\n  if (shape != null && shape.length !== 5) {\n    throw new Error('tensor5d() requires shape to have five numbers');\n  }\n\n  const inferredShape = inferShape(values, dtype);\n\n  if (inferredShape.length !== 5 && inferredShape.length !== 1) {\n    throw new Error('tensor5d() requires values to be ' + 'number[][][][][] or flat/TypedArray');\n  }\n\n  if (inferredShape.length === 1 && shape == null) {\n    throw new Error('tensor5d() requires shape to be provided when `values` ' + 'are a flat array');\n  }\n\n  return makeTensor(values, shape, inferredShape, dtype);\n}\n/**\n * Creates rank-6 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor6d` as it makes the code more readable.\n *\n *  ```js\n * // Pass a nested array.\n * tf.tensor6d([[[[[[1],[2]],[[3],[4]]],[[[5],[6]],[[7],[8]]]]]]).print();\n * ```\n * ```js\n * // Pass a flat array and specify a shape.\n * tf.tensor6d([1, 2, 3, 4, 5, 6, 7, 8], [1, 1, 2, 2, 2, 1]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`.\n * @param shape The shape of the tensor. Optional. If not provided,\n *   it is inferred from `values`.\n * @param dtype The data type.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\n\nfunction tensor6d(values, shape, dtype) {\n  assertNonNull(values);\n\n  if (shape != null && shape.length !== 6) {\n    throw new Error('tensor6d() requires shape to have six numbers');\n  }\n\n  const inferredShape = inferShape(values, dtype);\n\n  if (inferredShape.length !== 6 && inferredShape.length !== 1) {\n    throw new Error('tensor6d() requires values to be number[][][][][][] or ' + 'flat/TypedArray');\n  }\n\n  if (inferredShape.length === 1 && shape == null) {\n    throw new Error('tensor6d() requires shape to be provided when `values` ' + 'are a flat array');\n  }\n\n  shape = shape || inferredShape;\n  return makeTensor(values, shape, inferredShape, dtype);\n}\n/**\n * Creates a new variable with the provided initial value.\n * ```js\n * const x = tf.variable(tf.tensor([1, 2, 3]));\n * x.assign(tf.tensor([4, 5, 6]));\n *\n * x.print();\n * ```\n *\n * @param initialValue Initial value for the tensor.\n * @param trainable If true, optimizers are allowed to update it.\n * @param name Name of the variable. Defaults to a unique id.\n * @param dtype If set, initialValue will be converted to the given type.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\n\nfunction variable(initialValue, trainable = true, name, dtype) {\n  return ENGINE.makeVariable(initialValue, trainable, name, dtype);\n}\n/**\n * Creates a `tf.Tensor` with all elements set to 1.\n *\n * ```js\n * tf.ones([2, 2]).print();\n * ```\n *\n * @param shape An array of integers defining the output tensor shape.\n * @param dtype The type of an element in the resulting tensor. Defaults to\n *     'float'.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\n\nfunction ones(shape, dtype = 'float32') {\n  if (dtype === 'complex64') {\n    const real = ones(shape, 'float32');\n    const imag = zeros(shape, 'float32');\n    return complex(real, imag);\n  }\n\n  const values = makeOnesTypedArray(sizeFromShape(shape), dtype);\n  return ENGINE.makeTensor(values, shape, dtype);\n}\n/**\n * Creates a `tf.Tensor` with all elements set to 0.\n *\n * ```js\n * tf.zeros([2, 2]).print();\n * ```\n *\n * @param shape An array of integers defining the output tensor shape.\n * @param dtype The type of an element in the resulting tensor. Can\n *     be 'float32', 'int32' or 'bool'. Defaults to 'float'.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\n\nfunction zeros(shape, dtype = 'float32') {\n  if (dtype === 'complex64') {\n    const real = zeros(shape, 'float32');\n    const imag = zeros(shape, 'float32');\n    return complex(real, imag);\n  }\n\n  const values = makeZerosTypedArray(sizeFromShape(shape), dtype);\n  return ENGINE.makeTensor(values, shape, dtype);\n}\n/**\n * Creates a `tf.Tensor` with all elements set to 1 with the same shape as the\n * given tensor.\n *\n * ```js\n * const x = tf.tensor([1, 2]);\n * tf.onesLike(x).print();\n * ```\n * @param x A tensor.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\n\nfunction onesLike_(x) {\n  const $x = convertToTensor(x, 'x', 'onesLike');\n\n  if ($x.dtype === 'complex64') {\n    const r = onesLike(real($x));\n    const i = zerosLike(imag($x));\n    return complex(r, i);\n  }\n\n  const der = (dy, saved) => ({\n    x: () => zerosLike(dy)\n  });\n\n  return ENGINE.runKernelFunc(backend => backend.onesLike($x), {\n    x: $x\n  }, der, 'OnesLike');\n}\n/**\n * Creates a `tf.Tensor` with all elements set to 0 with the same shape as the\n * given tensor.\n *\n * ```js\n * const x = tf.tensor([1, 2]);\n * tf.zerosLike(x).print();\n * ```\n *\n * @param x The tensor of required shape.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\n\nfunction zerosLike_(x) {\n  const $x = convertToTensor(x, 'x', 'zerosLike');\n\n  const der = (dy, saved) => ({\n    x: () => zerosLike(dy)\n  });\n\n  return ENGINE.runKernelFunc(backend => backend.zerosLike($x), {\n    x: $x\n  }, der, 'ZerosLike');\n}\n/**\n * Return an evenly spaced sequence of numbers over the given interval.\n *\n * ```js\n * tf.linspace(0, 9, 10).print();\n * ```\n * @param start The start value of the sequence.\n * @param stop The end value of the sequence.\n * @param num The number of values to generate.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\n\nfunction linspace(start, stop, num) {\n  if (num <= 0) {\n    throw new Error('The number of values should be positive.');\n  }\n\n  return ENGINE.runKernelFunc(backend => backend.linspace(start, stop, num), {});\n}\n/**\n * Creates a new `tf.Tensor1D` filled with the numbers in the range provided.\n *\n * The tensor is a is half-open interval meaning it includes start, but\n * excludes stop. Decrementing ranges and negative step values are also\n * supported.\n *\n * ```js\n * tf.range(0, 9, 2).print();\n * ```\n *\n * @param start An integer start value\n * @param stop An integer stop value\n * @param step An integer increment (will default to 1 or -1)\n * @param dtype The data type of the output tensor. Defaults to 'float32'.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\n\nfunction range(start, stop, step = 1, dtype = 'float32') {\n  if (step === 0) {\n    throw new Error('Cannot have a step of zero');\n  }\n\n  const sameStartStop = start === stop;\n  const increasingRangeNegativeStep = start < stop && step < 0;\n  const decreasingRangePositiveStep = stop < start && step > 1;\n\n  if (sameStartStop || increasingRangeNegativeStep || decreasingRangePositiveStep) {\n    return zeros([0], dtype);\n  }\n\n  const numElements = Math.abs(Math.ceil((stop - start) / step));\n  const values = makeZerosTypedArray(numElements, dtype);\n\n  if (stop < start && step === 1) {\n    // Auto adjust the step's sign if it hasn't been set\n    // (or was set to 1)\n    step = -1;\n  }\n\n  values[0] = start;\n\n  for (let i = 1; i < values.length; i++) {\n    values[i] = values[i - 1] + step;\n  }\n\n  return tensor1d(values, dtype);\n}\n\nexport { linspace, ones, range, scalar, tensor, tensor1d, tensor2d, tensor3d, tensor4d, tensor5d, tensor6d, variable, zeros };\nexport const onesLike = op({\n  onesLike_\n});\nexport const zerosLike = op({\n  zerosLike_\n});","map":{"version":3,"sources":["../../src/ops/tensor_ops.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { env } from '../environment';\nimport { convertToTensor, inferShape } from '../tensor_util_env';\nimport { assert, assertNonNegativeIntegerDimensions, assertNonNull, flatten, inferDtype, isTypedArray, makeOnesTypedArray, makeZerosTypedArray, sizeFromShape, toTypedArray } from '../util';\nimport { complex } from './complex';\nimport { imag } from './imag';\nimport { op } from './operation';\nimport { real } from './real';\n/**\n * Creates a `tf.Tensor` with the provided values, shape and dtype.\n *\n * ```js\n * // Pass an array of values to create a vector.\n * tf.tensor([1, 2, 3, 4]).print();\n * ```\n *\n * ```js\n * // Pass a nested array of values to make a matrix or a higher\n * // dimensional tensor.\n * tf.tensor([[1, 2], [3, 4]]).print();\n * ```\n *\n * ```js\n * // Pass a flat array and specify a shape yourself.\n * tf.tensor([1, 2, 3, 4], [2, 2]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`. If the values are strings,\n *     they will be encoded as utf-8 and kept as `Uint8Array[]`.\n * @param shape The shape of the tensor. Optional. If not provided,\n *   it is inferred from `values`.\n * @param dtype The data type.\n */\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\nfunction tensor(values, shape, dtype) {\n    const inferredShape = inferShape(values, dtype);\n    return makeTensor(values, shape, inferredShape, dtype);\n}\n/** This is shared code across all tensor creation methods. */\nfunction makeTensor(values, shape, inferredShape, dtype) {\n    if (dtype == null) {\n        dtype = inferDtype(values);\n    }\n    if (dtype === 'complex64') {\n        throw new Error(`Cannot construct a complex64 tensor directly. ` +\n            `Please use tf.complex(real, imag).`);\n    }\n    if (!isTypedArray(values) && !Array.isArray(values) &&\n        typeof values !== 'number' && typeof values !== 'boolean' &&\n        typeof values !== 'string') {\n        throw new Error('values passed to tensor(values) must be a number/boolean/string or ' +\n            'an array of numbers/booleans/strings, or a TypedArray');\n    }\n    if (shape != null) {\n        assertNonNegativeIntegerDimensions(shape);\n        const providedSize = sizeFromShape(shape);\n        const inferredSize = sizeFromShape(inferredShape);\n        assert(providedSize === inferredSize, () => `Based on the provided shape, [${shape}], the tensor should have ` +\n            `${providedSize} values but has ${inferredSize}`);\n        for (let i = 0; i < inferredShape.length; ++i) {\n            const inferred = inferredShape[i];\n            const flatDimsDontMatch = i === inferredShape.length - 1 ?\n                inferred !== sizeFromShape(shape.slice(i)) :\n                true;\n            assert(inferredShape[i] === shape[i] || !flatDimsDontMatch, () => `Error creating a new Tensor. Inferred shape ` +\n                `(${inferredShape}) does not match the provided ` +\n                `shape (${shape}). `);\n        }\n    }\n    if (!isTypedArray(values) && !Array.isArray(values)) {\n        values = [values];\n    }\n    shape = shape || inferredShape;\n    values = dtype !== 'string' ?\n        toTypedArray(values, dtype, env().getBool('DEBUG')) :\n        flatten(values, [], true);\n    return ENGINE.makeTensor(values, shape, dtype);\n}\n/**\n * Creates rank-0 `tf.Tensor` (scalar) with the provided value and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.scalar` as it makes the code more readable.\n *\n * ```js\n * tf.scalar(3.14).print();\n * ```\n *\n * @param value The value of the scalar.\n * @param dtype The data type.\n */\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\nfunction scalar(value, dtype) {\n    if (((isTypedArray(value) && dtype !== 'string') || Array.isArray(value)) &&\n        dtype !== 'complex64') {\n        throw new Error('Error creating a new Scalar: value must be a primitive ' +\n            '(number|boolean|string)');\n    }\n    if (dtype === 'string' && isTypedArray(value) &&\n        !(value instanceof Uint8Array)) {\n        throw new Error('When making a scalar from encoded string, ' +\n            'the value must be `Uint8Array`.');\n    }\n    const shape = [];\n    const inferredShape = [];\n    return makeTensor(value, shape, inferredShape, dtype);\n}\n/**\n * Creates rank-1 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor1d` as it makes the code more readable.\n *\n * ```js\n * tf.tensor1d([1, 2, 3]).print();\n * ```\n *\n * @param values The values of the tensor. Can be array of numbers,\n *     or a `TypedArray`.\n * @param dtype The data type.\n */\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\nfunction tensor1d(values, dtype) {\n    assertNonNull(values);\n    const inferredShape = inferShape(values, dtype);\n    if (inferredShape.length !== 1) {\n        throw new Error('tensor1d() requires values to be a flat/TypedArray');\n    }\n    const shape = null;\n    return makeTensor(values, shape, inferredShape, dtype);\n}\n/**\n * Creates rank-2 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor2d` as it makes the code more readable.\n *\n *  ```js\n * // Pass a nested array.\n * tf.tensor2d([[1, 2], [3, 4]]).print();\n * ```\n * ```js\n * // Pass a flat array and specify a shape.\n * tf.tensor2d([1, 2, 3, 4], [2, 2]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`.\n * @param shape The shape of the tensor. If not provided, it is inferred from\n *     `values`.\n * @param dtype The data type.\n */\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\nfunction tensor2d(values, shape, dtype) {\n    assertNonNull(values);\n    if (shape != null && shape.length !== 2) {\n        throw new Error('tensor2d() requires shape to have two numbers');\n    }\n    const inferredShape = inferShape(values, dtype);\n    if (inferredShape.length !== 2 && inferredShape.length !== 1) {\n        throw new Error('tensor2d() requires values to be number[][] or flat/TypedArray');\n    }\n    if (inferredShape.length === 1 && shape == null) {\n        throw new Error('tensor2d() requires shape to be provided when `values` ' +\n            'are a flat/TypedArray');\n    }\n    return makeTensor(values, shape, inferredShape, dtype);\n}\n/**\n * Creates rank-3 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor3d` as it makes the code more readable.\n *\n *  ```js\n * // Pass a nested array.\n * tf.tensor3d([[[1], [2]], [[3], [4]]]).print();\n * ```\n * ```js\n * // Pass a flat array and specify a shape.\n * tf.tensor3d([1, 2, 3, 4], [2, 2, 1]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`.\n * @param shape The shape of the tensor. If not provided,  it is inferred from\n *     `values`.\n * @param dtype The data type.\n */\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\nfunction tensor3d(values, shape, dtype) {\n    assertNonNull(values);\n    if (shape != null && shape.length !== 3) {\n        throw new Error('tensor3d() requires shape to have three numbers');\n    }\n    const inferredShape = inferShape(values, dtype);\n    if (inferredShape.length !== 3 && inferredShape.length !== 1) {\n        throw new Error('tensor3d() requires values to be number[][][] or flat/TypedArray');\n    }\n    if (inferredShape.length === 1 && shape == null) {\n        throw new Error('tensor3d() requires shape to be provided when `values` ' +\n            'are a flat array');\n    }\n    return makeTensor(values, shape, inferredShape, dtype);\n}\n/**\n * Creates rank-4 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor4d` as it makes the code more readable.\n *\n *  ```js\n * // Pass a nested array.\n * tf.tensor4d([[[[1], [2]], [[3], [4]]]]).print();\n * ```\n * ```js\n * // Pass a flat array and specify a shape.\n * tf.tensor4d([1, 2, 3, 4], [1, 2, 2, 1]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`.\n * @param shape The shape of the tensor. Optional. If not provided,\n *   it is inferred from `values`.\n * @param dtype The data type.\n */\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\nfunction tensor4d(values, shape, dtype) {\n    assertNonNull(values);\n    if (shape != null && shape.length !== 4) {\n        throw new Error('tensor4d() requires shape to have four numbers');\n    }\n    const inferredShape = inferShape(values, dtype);\n    if (inferredShape.length !== 4 && inferredShape.length !== 1) {\n        throw new Error('tensor4d() requires values to be number[][][][] or flat/TypedArray');\n    }\n    if (inferredShape.length === 1 && shape == null) {\n        throw new Error('tensor4d() requires shape to be provided when `values` ' +\n            'are a flat array');\n    }\n    return makeTensor(values, shape, inferredShape, dtype);\n}\n/**\n * Creates rank-5 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor5d` as it makes the code more readable.\n *\n *  ```js\n * // Pass a nested array.\n * tf.tensor5d([[[[[1], [2]], [[3], [4]]]]]).print();\n * ```\n * ```js\n * // Pass a flat array and specify a shape.\n * tf.tensor5d([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 2, 2, 1]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`.\n * @param shape The shape of the tensor. Optional. If not provided,\n *   it is inferred from `values`.\n * @param dtype The data type.\n */\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\nfunction tensor5d(values, shape, dtype) {\n    assertNonNull(values);\n    if (shape != null && shape.length !== 5) {\n        throw new Error('tensor5d() requires shape to have five numbers');\n    }\n    const inferredShape = inferShape(values, dtype);\n    if (inferredShape.length !== 5 && inferredShape.length !== 1) {\n        throw new Error('tensor5d() requires values to be ' +\n            'number[][][][][] or flat/TypedArray');\n    }\n    if (inferredShape.length === 1 && shape == null) {\n        throw new Error('tensor5d() requires shape to be provided when `values` ' +\n            'are a flat array');\n    }\n    return makeTensor(values, shape, inferredShape, dtype);\n}\n/**\n * Creates rank-6 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor6d` as it makes the code more readable.\n *\n *  ```js\n * // Pass a nested array.\n * tf.tensor6d([[[[[[1],[2]],[[3],[4]]],[[[5],[6]],[[7],[8]]]]]]).print();\n * ```\n * ```js\n * // Pass a flat array and specify a shape.\n * tf.tensor6d([1, 2, 3, 4, 5, 6, 7, 8], [1, 1, 2, 2, 2, 1]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`.\n * @param shape The shape of the tensor. Optional. If not provided,\n *   it is inferred from `values`.\n * @param dtype The data type.\n */\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\nfunction tensor6d(values, shape, dtype) {\n    assertNonNull(values);\n    if (shape != null && shape.length !== 6) {\n        throw new Error('tensor6d() requires shape to have six numbers');\n    }\n    const inferredShape = inferShape(values, dtype);\n    if (inferredShape.length !== 6 && inferredShape.length !== 1) {\n        throw new Error('tensor6d() requires values to be number[][][][][][] or ' +\n            'flat/TypedArray');\n    }\n    if (inferredShape.length === 1 && shape == null) {\n        throw new Error('tensor6d() requires shape to be provided when `values` ' +\n            'are a flat array');\n    }\n    shape = shape ||\n        inferredShape;\n    return makeTensor(values, shape, inferredShape, dtype);\n}\n/**\n * Creates a new variable with the provided initial value.\n * ```js\n * const x = tf.variable(tf.tensor([1, 2, 3]));\n * x.assign(tf.tensor([4, 5, 6]));\n *\n * x.print();\n * ```\n *\n * @param initialValue Initial value for the tensor.\n * @param trainable If true, optimizers are allowed to update it.\n * @param name Name of the variable. Defaults to a unique id.\n * @param dtype If set, initialValue will be converted to the given type.\n */\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\nfunction variable(initialValue, trainable = true, name, dtype) {\n    return ENGINE.makeVariable(initialValue, trainable, name, dtype);\n}\n/**\n * Creates a `tf.Tensor` with all elements set to 1.\n *\n * ```js\n * tf.ones([2, 2]).print();\n * ```\n *\n * @param shape An array of integers defining the output tensor shape.\n * @param dtype The type of an element in the resulting tensor. Defaults to\n *     'float'.\n */\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\nfunction ones(shape, dtype = 'float32') {\n    if (dtype === 'complex64') {\n        const real = ones(shape, 'float32');\n        const imag = zeros(shape, 'float32');\n        return complex(real, imag);\n    }\n    const values = makeOnesTypedArray(sizeFromShape(shape), dtype);\n    return ENGINE.makeTensor(values, shape, dtype);\n}\n/**\n * Creates a `tf.Tensor` with all elements set to 0.\n *\n * ```js\n * tf.zeros([2, 2]).print();\n * ```\n *\n * @param shape An array of integers defining the output tensor shape.\n * @param dtype The type of an element in the resulting tensor. Can\n *     be 'float32', 'int32' or 'bool'. Defaults to 'float'.\n */\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\nfunction zeros(shape, dtype = 'float32') {\n    if (dtype === 'complex64') {\n        const real = zeros(shape, 'float32');\n        const imag = zeros(shape, 'float32');\n        return complex(real, imag);\n    }\n    const values = makeZerosTypedArray(sizeFromShape(shape), dtype);\n    return ENGINE.makeTensor(values, shape, dtype);\n}\n/**\n * Creates a `tf.Tensor` with all elements set to 1 with the same shape as the\n * given tensor.\n *\n * ```js\n * const x = tf.tensor([1, 2]);\n * tf.onesLike(x).print();\n * ```\n * @param x A tensor.\n */\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\nfunction onesLike_(x) {\n    const $x = convertToTensor(x, 'x', 'onesLike');\n    if ($x.dtype === 'complex64') {\n        const r = onesLike(real($x));\n        const i = zerosLike(imag($x));\n        return complex(r, i);\n    }\n    const der = (dy, saved) => ({ x: () => zerosLike(dy) });\n    return ENGINE.runKernelFunc(backend => backend.onesLike($x), { x: $x }, der, 'OnesLike');\n}\n/**\n * Creates a `tf.Tensor` with all elements set to 0 with the same shape as the\n * given tensor.\n *\n * ```js\n * const x = tf.tensor([1, 2]);\n * tf.zerosLike(x).print();\n * ```\n *\n * @param x The tensor of required shape.\n */\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\nfunction zerosLike_(x) {\n    const $x = convertToTensor(x, 'x', 'zerosLike');\n    const der = (dy, saved) => ({ x: () => zerosLike(dy) });\n    return ENGINE.runKernelFunc(backend => backend.zerosLike($x), { x: $x }, der, 'ZerosLike');\n}\n/**\n * Return an evenly spaced sequence of numbers over the given interval.\n *\n * ```js\n * tf.linspace(0, 9, 10).print();\n * ```\n * @param start The start value of the sequence.\n * @param stop The end value of the sequence.\n * @param num The number of values to generate.\n */\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\nfunction linspace(start, stop, num) {\n    if (num <= 0) {\n        throw new Error('The number of values should be positive.');\n    }\n    return ENGINE.runKernelFunc(backend => backend.linspace(start, stop, num), {});\n}\n/**\n * Creates a new `tf.Tensor1D` filled with the numbers in the range provided.\n *\n * The tensor is a is half-open interval meaning it includes start, but\n * excludes stop. Decrementing ranges and negative step values are also\n * supported.\n *\n * ```js\n * tf.range(0, 9, 2).print();\n * ```\n *\n * @param start An integer start value\n * @param stop An integer stop value\n * @param step An integer increment (will default to 1 or -1)\n * @param dtype The data type of the output tensor. Defaults to 'float32'.\n */\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\nfunction range(start, stop, step = 1, dtype = 'float32') {\n    if (step === 0) {\n        throw new Error('Cannot have a step of zero');\n    }\n    const sameStartStop = start === stop;\n    const increasingRangeNegativeStep = start < stop && step < 0;\n    const decreasingRangePositiveStep = stop < start && step > 1;\n    if (sameStartStop || increasingRangeNegativeStep ||\n        decreasingRangePositiveStep) {\n        return zeros([0], dtype);\n    }\n    const numElements = Math.abs(Math.ceil((stop - start) / step));\n    const values = makeZerosTypedArray(numElements, dtype);\n    if (stop < start && step === 1) {\n        // Auto adjust the step's sign if it hasn't been set\n        // (or was set to 1)\n        step = -1;\n    }\n    values[0] = start;\n    for (let i = 1; i < values.length; i++) {\n        values[i] = values[i - 1] + step;\n    }\n    return tensor1d(values, dtype);\n}\nexport { linspace, ones, range, scalar, tensor, tensor1d, tensor2d, tensor3d, tensor4d, tensor5d, tensor6d, variable, zeros };\nexport const onesLike = op({ onesLike_ });\nexport const zerosLike = op({ zerosLike_ });\n//# sourceMappingURL=tensor_ops.js.map"]},"metadata":{},"sourceType":"module"}