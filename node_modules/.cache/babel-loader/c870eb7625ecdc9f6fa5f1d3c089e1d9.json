{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { convertToTensor } from '../tensor_util_env';\nimport { parseAxisParam } from '../util';\nimport * as axis_util from './axis_util';\nimport { op } from './operation';\nimport { scalar } from './tensor_ops';\n/**\n * Computes the norm of scalar, vectors, and matrices.\n * This function can compute several different vector norms (the 1-norm, the\n * Euclidean or 2-norm, the inf-norm, and in general the p-norm for p > 0)\n * and matrix norms (Frobenius, 1-norm, and inf-norm).\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n *\n * x.norm().print();  // or tf.norm(x)\n * ```\n *\n * @param x The input array.\n * @param ord Optional. Order of the norm. Supported norm types are\n * following:\n *\n *  | ord        | norm for matrices         | norm for vectors\n *  |------------|---------------------------|---------------------\n *  |'euclidean' |Frobenius norm             |2-norm\n *  |'fro'       |Frobenius norm\t           |\n *  |Infinity    |max(sum(abs(x), axis=1))   |max(abs(x))\n *  |-Infinity   |min(sum(abs(x), axis=1))   |min(abs(x))\n *  |1           |max(sum(abs(x), axis=0))   |sum(abs(x))\n *  |2           |                           |sum(abs(x)^2)^1/2*\n *\n * @param axis Optional. If axis is null (the default), the input is\n * considered a vector and a single vector norm is computed over the entire\n * set of values in the Tensor, i.e. norm(x, ord) is equivalent\n * to norm(x.reshape([-1]), ord). If axis is a integer, the input\n * is considered a batch of vectors, and axis determines the axis in x\n * over which to compute vector norms. If axis is a 2-tuple of integer it is\n * considered a batch of matrices and axis determines the axes in NDArray\n * over which to compute a matrix norm.\n * @param keepDims Optional. If true, the norm have the same dimensionality\n * as the input.\n */\n\n/** @doc {heading: 'Operations', subheading: 'Matrices'} */\n\nfunction norm_(x, ord = 'euclidean', axis = null, keepDims = false) {\n  x = convertToTensor(x, 'x', 'norm');\n  const norm = normImpl(x, ord, axis);\n  let keepDimsShape = norm.shape;\n\n  if (keepDims) {\n    const axes = parseAxisParam(axis, x.shape);\n    keepDimsShape = axis_util.expandShapeToKeepDim(norm.shape, axes);\n  }\n\n  return norm.reshape(keepDimsShape);\n}\n\nfunction normImpl(x, p, axis = null) {\n  if (x.rank === 0) {\n    return x.abs();\n  } // consider vector when no axis is specified\n\n\n  if (x.rank !== 1 && axis === null) {\n    return normImpl(x.reshape([-1]), p, axis);\n  } // vector\n\n\n  if (x.rank === 1 || typeof axis === 'number' || Array.isArray(axis) && axis.length === 1) {\n    if (p === 1) {\n      return x.abs().sum(axis);\n    }\n\n    if (p === Infinity) {\n      return x.abs().max(axis);\n    }\n\n    if (p === -Infinity) {\n      return x.abs().min(axis);\n    }\n\n    if (p === 'euclidean' || p === 2) {\n      // norm(x, 2) = sum(abs(xi) ^ 2) ^ 1/2\n      return x.abs().pow(scalar(2, 'int32')).sum(axis).sqrt();\n    }\n\n    throw new Error(`Error in norm: invalid ord value: ${p}`);\n  } // matrix (assumption axis[0] < axis[1])\n\n\n  if (Array.isArray(axis) && axis.length === 2) {\n    if (p === 1) {\n      return x.abs().sum(axis[0]).max(axis[1] - 1);\n    }\n\n    if (p === Infinity) {\n      return x.abs().sum(axis[1]).max(axis[0]);\n    }\n\n    if (p === -Infinity) {\n      return x.abs().sum(axis[1]).min(axis[0]);\n    }\n\n    if (p === 'fro' || p === 'euclidean') {\n      // norm(x) = sqrt(sum(pow(x, 2)))\n      return x.square().sum(axis).sqrt();\n    }\n\n    throw new Error(`Error in norm: invalid ord value: ${p}`);\n  }\n\n  throw new Error(`Error in norm: invalid axis: ${axis}`);\n}\n\nexport const norm = op({\n  norm_\n});","map":{"version":3,"sources":["../../src/ops/norm.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { convertToTensor } from '../tensor_util_env';\nimport { parseAxisParam } from '../util';\nimport * as axis_util from './axis_util';\nimport { op } from './operation';\nimport { scalar } from './tensor_ops';\n/**\n * Computes the norm of scalar, vectors, and matrices.\n * This function can compute several different vector norms (the 1-norm, the\n * Euclidean or 2-norm, the inf-norm, and in general the p-norm for p > 0)\n * and matrix norms (Frobenius, 1-norm, and inf-norm).\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n *\n * x.norm().print();  // or tf.norm(x)\n * ```\n *\n * @param x The input array.\n * @param ord Optional. Order of the norm. Supported norm types are\n * following:\n *\n *  | ord        | norm for matrices         | norm for vectors\n *  |------------|---------------------------|---------------------\n *  |'euclidean' |Frobenius norm             |2-norm\n *  |'fro'       |Frobenius norm\t           |\n *  |Infinity    |max(sum(abs(x), axis=1))   |max(abs(x))\n *  |-Infinity   |min(sum(abs(x), axis=1))   |min(abs(x))\n *  |1           |max(sum(abs(x), axis=0))   |sum(abs(x))\n *  |2           |                           |sum(abs(x)^2)^1/2*\n *\n * @param axis Optional. If axis is null (the default), the input is\n * considered a vector and a single vector norm is computed over the entire\n * set of values in the Tensor, i.e. norm(x, ord) is equivalent\n * to norm(x.reshape([-1]), ord). If axis is a integer, the input\n * is considered a batch of vectors, and axis determines the axis in x\n * over which to compute vector norms. If axis is a 2-tuple of integer it is\n * considered a batch of matrices and axis determines the axes in NDArray\n * over which to compute a matrix norm.\n * @param keepDims Optional. If true, the norm have the same dimensionality\n * as the input.\n */\n/** @doc {heading: 'Operations', subheading: 'Matrices'} */\nfunction norm_(x, ord = 'euclidean', axis = null, keepDims = false) {\n    x = convertToTensor(x, 'x', 'norm');\n    const norm = normImpl(x, ord, axis);\n    let keepDimsShape = norm.shape;\n    if (keepDims) {\n        const axes = parseAxisParam(axis, x.shape);\n        keepDimsShape = axis_util.expandShapeToKeepDim(norm.shape, axes);\n    }\n    return norm.reshape(keepDimsShape);\n}\nfunction normImpl(x, p, axis = null) {\n    if (x.rank === 0) {\n        return x.abs();\n    }\n    // consider vector when no axis is specified\n    if (x.rank !== 1 && axis === null) {\n        return normImpl(x.reshape([-1]), p, axis);\n    }\n    // vector\n    if (x.rank === 1 || typeof axis === 'number' ||\n        Array.isArray(axis) && axis.length === 1) {\n        if (p === 1) {\n            return x.abs().sum(axis);\n        }\n        if (p === Infinity) {\n            return x.abs().max(axis);\n        }\n        if (p === -Infinity) {\n            return x.abs().min(axis);\n        }\n        if (p === 'euclidean' || p === 2) {\n            // norm(x, 2) = sum(abs(xi) ^ 2) ^ 1/2\n            return x.abs().pow(scalar(2, 'int32')).sum(axis).sqrt();\n        }\n        throw new Error(`Error in norm: invalid ord value: ${p}`);\n    }\n    // matrix (assumption axis[0] < axis[1])\n    if (Array.isArray(axis) && axis.length === 2) {\n        if (p === 1) {\n            return x.abs().sum(axis[0]).max(axis[1] - 1);\n        }\n        if (p === Infinity) {\n            return x.abs().sum(axis[1]).max(axis[0]);\n        }\n        if (p === -Infinity) {\n            return x.abs().sum(axis[1]).min(axis[0]);\n        }\n        if (p === 'fro' || p === 'euclidean') {\n            // norm(x) = sqrt(sum(pow(x, 2)))\n            return x.square().sum(axis).sqrt();\n        }\n        throw new Error(`Error in norm: invalid ord value: ${p}`);\n    }\n    throw new Error(`Error in norm: invalid axis: ${axis}`);\n}\nexport const norm = op({ norm_ });\n//# sourceMappingURL=norm.js.map"]},"metadata":{},"sourceType":"module"}